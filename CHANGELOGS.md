## Change log

This document shows the history of when a specific sample was introduced to the oneAPI ecosystem of Code Samples.<br>Current Samples Count: 157
| Version|Code Sample Name|description|
|-----------------------|------------------|-------------------------|
|2021.4.0|[Chapter 01 - Introduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch01_intro)|fig_1_1_hello.cpp - Hello data-parallel programming * fig_1_3_race.cpp - Adding a race condition to illustrate a point about being asynchronous * fig_1_4_lambda.cpp - Lambda function in C++ code * fig_1_6_functor.cpp - Function object instead of a lambda (more on this in Chapter 10)|
|2021.4.0|[Chapter 02 - Where Code Executes](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch02_where_code_runs)|fig_2_2_simple_program.cpp - Simple SYCL program  * fig_2_7_implicit_default_selector.cpp - Implicit default device selector through trivial construction of a queue  * fig_2_9_host_selector.cpp - Selecting the host device using the host_selector class * fig_2_10_cpu_selector.cpp - CPU device selector example * fig_2_12_multiple_selectors.cpp  - Example device identification output from various classes of device selectors and demonstration that device selectors can be used for cons * fig_2_13_gpu_plus_fpga.cpp - Creating queues to both GPU and FPGA devices  * fig_2_15_custom_selector.cpp - Custom selector for Intel Arria FPGA device  * fig_2_18_simple_device_code.cpp - Submission of device code  * fig_2_22_simple_device_code_2.cpp - Submission of device code  * fig_2_23_fallback.cpp - Fallback queue example|
|2021.4.0|[Chapter 03 - Data Management](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch03_data_management)|fig_3_4_usm_explicit_data_movement.cpp - USM explicit data movement  * fig_3_5_usm_implicit_data_movement.cpp - USM implicit data movement  * fig_3_6_buffers_and_accessors.cpp - Buffers and accessors  * fig_3_10_in_order.cpp - In-order queue usage  * fig_3_11_depends_on.cpp - Using events and depends_on * fig_3_13_read_after_write.cpp - Read-after-Write  * fig_3_15_write_after_read_and_write_after_write.cpp - Write-after-Read and Write-after-Write |
|2021.4.0|[Chapter 04 - Expresssing Parallelism](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch04_expressing_parallelism)|fig_4_5_vector_add.cpp - Expressing a vector addition kernel with parallel_for * fig_4_6_matrix_add.cpp - Expressing a matrix addition kernel with parallel_for * fig_4_7_basic_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel for square matrices, with parallel_for * fig_4_13_nd_range_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with ND-range parallel_for * fig_4_20_hierarchical_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with hierarchical parallelism * fig_4_22_hierarchical_logical_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with hierarchical parallelism and a logical range|
|2021.4.0|[Chapter 05 - Error Handling](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch05_error_handling)|fig_5_1_async_task_graph.cpp - Separation of host program and task graph executions * fig_5_2_sync_error.cpp - Creating a synchronous error * fig_5_3_async_error.cpp - Creating an asynchronous error * fig_5_4_unhandled_exception.cpp - Unhandled exception in C++ * fig_5_5_terminate.cpp - std::terminate is called when a SYCL asynchronous exception isn’t handled * fig_5_6_catch_snip.cpp - Pattern to catch sycl::exception specifically * fig_5_7_catch.cpp - Pattern to catch exceptions from a block of code * fig_5_8_lambda_handler.cpp - Example asynchronous handler implementation defined as a lambda * fig_5_9_default_handler_proxy.cpp - Example of how the default asynchronous handler behaves |
|2021.4.0|[Chapter 06 - Unified Shared Memory](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch06_unified_shared_memory)|fig_6_5_allocation_styles.cpp - Three styles for allocation * fig_6_6_usm_explicit_data_movement.cpp - USM explicit data movement example * fig_6_7_usm_implicit_data_movement.cpp - USM implicit data movement example * fig_6_8_prefetch_memadvise.cpp - Fine-grained control via prefetch and mem_advise * fig_6_9_queries.cpp - Queries on USM pointers and devices |
|2021.4.0|[Chapter 07 - Buffers](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch07_buffers)|fig_7_2_3_4_creating_buffers.cpp - Creating buffers, Part 1 - Figure 7-3. Creating buffers, Part 2  - Figure 7-4. Creating buffers, Part 3 * fig_7_5_buffer_properties.cpp - Buffer properties * fig_7_8_accessors_simple.cpp - Simple accessor creation * fig_7_10_accessors.cpp - Accessor creation with specified usage|
|2021.4.0|[Chapter 08 - Scheduling Kernals and Data Movement](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch08_graph_scheduling)|fig_8_3_linear_dependence_in_order.cpp - Linear dependence chain with in-order queues * fig_8_4_linear_dependence_events.cpp - Linear dependence chain with events * fig_8_5_linear_dependence_buffers.cpp - Linear dependence chain with buffers and accessors * fig_8_6_y_in_order.cpp - Y pattern with in-order queues * fig_8_7_y_events.cpp - Y pattern with events * fig_8_8_y_buffers.cpp - Y pattern with accessors|
|2021.4.0|[Chapter 09 - Communication and Synchronization](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch09_work_item_communication)|fig_9_4_naive_matrix_multiplication.cpp - The naïve matrix multiplication kernel from Chapter 4 * fig_9_7_local_accessors.cpp - Declaring and using local accessors * fig_9_8_ndrange_tiled_matrix_multiplication.cpp - Expressing a tiled matrix multiplication kernel with an ND-range parallel_for and work-group local memory * fig_9_9_local_hierarchical.cpp - Hierarchical kernel with a local memory variable * fig_9_10_hierarchical_tiled_matrix_multiplication.cpp - A tiled matrix multiplication kernel implemented as a hierarchical kernel * fig_9_11_sub_group_barrier.cpp - Querying and using the sub_group class * fig_9_13_matrix_multiplication_broadcast.cpp - Matrix multiplication kernel includes a broadcast operation * fig_9_14_ndrange_sub_group_matrix_multiplication.cpp - Tiled matrix multiplication kernel expressed with ND-range parallel_for and sub-group collective functions|
|2021.4.0|[Chapter 10 - Defining Kernels](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch10_expressing_kernels)|* fig_10_2_kernel_lambda.cpp - Kernel defined using a lambda expression * fig_10_3_optional_kernel_lambda_elements.cpp - More elements of a kernel lambda expression, including optional elements * fig_10_4_named_kernel_lambda.cpp - Naming kernel lambda expressions * fig_10_5_unnamed_kernel_lambda.cpp - Using unnamed kernel lambda expressions * fig_10_6_kernel_functor.cpp - Kernel as a named function object * fig_10_7_opencl_source_interop.cpp - Kernel created from OpenCL C kernel source * fig_10_8_opencl_object_interop.cpp - Kernel created from an OpenCL kernel object * fig_10_9_kernel_lambda_build_options.cpp - Compiling kernel lambdas with build options|
|2021.4.0|[Chapter 11 - Vectors](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch11_vectors)|fig_11_6_load_store.cpp - Use of load and store member functions. * fig_11_7_swizzle_vec.cpp - Example of using the __swizzled_vec__ class * fig_11_8_vector_exec.cpp - Vector execution example |
|2021.4.0|[Chapter 12 - Device Information](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch12_device_information)|fig_12_1_assigned_device.cpp - Device we have been assigned by default * fig_12_2_try_catch.cpp - Using try-catch to select a GPU device if possible, host device if not * fig_12_3_device_selector.cpp - Custom device selector—our preferred solution * fig_12_4_curious.cpp - Simple use of device query mechanisms: curious.cpp * fig_12_6_very_curious.cpp - More detailed use of device query mechanisms: verycurious.cpp * fig_12_7_invocation_parameters.cpp - Fetching parameters that can be used to shape a kernel|
|2021.4.0|[Chapter 13 - Practical Tips](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch13_practical_tips)|fig_13_4_stream.cpp - sycl::stream * fig_13_6_common_buffer_pattern.cpp - Common pattern—buffer creation from a host allocation * fig_13_7_common_pattern_bug.cpp - Common bug: Reading data directly from host allocation during buffer lifetime * fig_13_8_host_accessor.cpp - Recommendation: Use a host accessor to read kernel result * fig_13_9_host_accessor_for_init.cpp - Recommendation: Use host accessors for buffer initialization and reading of results * fig_13_10_host_accessor_deadlock.cpp - Bug (hang!) from improper use of host_accessors |
|2021.4.0|[Chapter 14 - Common Parallel Patterns](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch14_common_parallel_patterns)|fig_14_8_one_reduction.cpp - Reduction expressed as an ND-range data-parallel kernel using the reduction library * fig_14_11_user_defined_reduction.cpp - Using a user-defined reduction to find the location of the minimum value with an ND-range kernel * fig_14_13_map.cpp - Implementing the map pattern in a data-parallel kernel * fig_14_14_stencil.cpp - Implementing the stencil pattern in a data-parallel kernel * fig_14_15_local_stencil.cpp - Implementing the stencil pattern in an ND-range kernel, using work-group local memory * fig_14_18-20_inclusive_scan.cpp - Implementing a naïve reduction expressed as a  data-parallel kernel * fig_14_22_local_pack.cpp - Using a sub-group pack operation to build a list of elements needing additional postprocessing * fig_14_24_local_unpack.cpp - Using a sub-group unpack operation to improve load balancing for kernels with divergent control flow|
|2021.4.0|[Chapter 15 - Programming for GPUs](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch15_gpus)|fig_15_3_single_task_matrix_multiplication.cpp - A single task matrix multiplication looks a lot like CPU host code * fig_15_5_somewhat_parallel_matrix_multiplication.cpp - Somewhat-parallel matrix multiplication * fig_15_7_more_parallel_matrix_multiplication.cpp - Even more parallel matrix multiplication * fig_15_10_divergent_control_flow.cpp - Kernel with divergent control flow * fig_15_12_small_work_group_matrix_multiplication.cpp - Inefficient single-item, somewhat-parallel matrix multiplication * fig_15_18_columns_matrix_multiplication.cpp - Computing columns of the result matrix in parallel, not rows|
|2021.4.0|[Chapter 16 - Programming for CPUs](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch16_cpus)|fig_16_6_stream_triad.cpp - DPC++ STREAM Triad parallel_for kernel code * fig_16_12_forward_dep.cpp - Using a sub-group to vectorize a loop with a forward dependence * fig_16_18_vector_swizzle.cpp - Using vector types and swizzle operations in the single_task kernel|
|2021.4.0|[Chapter 17 - Programming for FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch17_fpgas)|fig_17_9_fpga_selector.cpp - Choosing an FPGA device at runtime using the * fig_17_11_fpga_emulator_selector.cpp - Using fpga_emulator_selector for rapid development and debugging * fig_17_17_ndrange_func.cpp - Multiple work-item (16 × 16 × 16) invocation of a random number generator * fig_17_18_loop_func.cpp - Loop-carried data dependence (state) * fig_17_20_loop_carried_deps.cpp - Loop with two loop-carried dependences (i.e., i and a) * fig_17_22_loop_carried_state.cpp - Random number generator that depends on previous value generated * fig_17_31_inter_kernel_pipe.cpp - Pipe between two kernels: (1) ND-range and (2) single task with a loop  |
|2021.4.0|[Chapter 18 - Libraries](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch18_using_libs)|fig_18_1_builtin.cpp - Using std::log and sycl::log * fig_18_7_swap.cpp - Using std::swap in device code * fig_18_11_std_fill.cpp - Using std::fill * fig_18_13_binary_search.cpp - Using binary_search *fig_18_15_pstl_usm.cpp - Using Parallel STL with a USM allocator * Errata - code samples for 18-10, 18-12, 18-14, and 19-17 are not in the repository |
|2021.4.0|[Chapter 19 - Memory Model and Atomics](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Ch19_memory_model_and_atomics)|fig_19_3_data_race.cpp - Kernel containing a data race * fig_19_6_avoid_data_race_with_barrier.cpp - Avoiding a data race using a barrier *  fig_19_7_avoid_data_race_with_atomics.cpp - Avoiding a data race using atomic operations * fig_19_15_buffer_and_atomic_ref.cpp - Accessing a buffer via an explicitly created atomic_ref * fig_19_16_atomic_accessor.cpp - Accessing a buffer via an atomic_ref implicitly created by an atomic accessor * fig_19_18_histogram.cpp - Computing a histogram using atomic references in different memory spaces *  fig_19_19-20_device_latch.cpp - Combining Figure 19-20. Using and building a simple device-wide latch on top of atomic references * Errata - code samples for 18-10, 18-12, 18-14, and 19-17 are not in the repository|
|2021.4.0|[Chapter 20 - Epilogue Future Direction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/Data_Parallel_C++/Epilogue_future_direction)|Epilogue source code examples: Future Direction of DPC++ * fig_ep_1_mdspan.cpp - Attaching accessor-like indexing to a USM pointer using mdspan * fig_ep_2-4_generic_space.cpp - Storing pointers to a specific address space in a class - Figure EP-3. Storing pointers to the generic address space in a class - Figure EP-4. Storing pointers with an optional address space in a class * fig_ep_5_extension_mechanism.cpp - Checking for Intel sub-group extension compiler support with #ifdef * fig_ep_6_device_constexpr.cpp - Specializing kernel code based on device aspects at kernel compile time * fig_ep_7_hierarchical_reduction.cpp - Using hierarchical parallelism for a hierarchical reduction|
|2021.4.0|[Merge Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/merge_sort)|A Reference design demonstrating merge sort on an Intel® FPGA|
|2021.4.0|[Private Copies](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/private_copies)|An Intel® FPGA tutorial demonstrating how to use the private_copies attribute to trade off the resource use and the throughput of a DPC++ FPGA program|
|2021.4.0|[Stall Enable](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/stall_enable)|An Intel® FPGA tutorial demonstrating the use_stall_enable_clusters attribute|
|2021.3.0|[IO streaming with DPC++ IO pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/io_streaming)|An FPGA tutorial describing how to stream data to and from DPC++ IO pipes.|
|2021.3.0|[Intel® Python XGBoost Performance](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_Performance)|This sample code illustrates how to analyze the performance benefit from using Intel optimizations upstreamed by Intel to latest XGBoost compared to un-optimized XGBoost 0.81 |
|2021.3.0|[Jacobi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/jacobi)|A small Intel® oneAPI Data Parallel C++ (DPC++) example which solves a harcoded linear system with Jacobi iteration. The sample includes two versions of the same program: with and without bugs.|
|2021.3.0|[Loop Initiation Interval](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_initiation_interval)|An Intel® FPGA tutorial demonstrating the usage of the initiation_interval attribute|
|2021.3.0|[MVDR Beamforming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/mvdr_beamforming)|A reference design demonstrating a high-performance streaming MVDR beamformer|
|2021.3.0|[OpenMP Offload C++ Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/Jupyter/OpenMP-offload-training)|C++ OpenMP Offload Basics using Jupyter Notebooks|
|2021.3.0|[OpenMP Offload Feature Samples](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/OpenMP_Offload_Features)|Samples showing new OpenMP Offload features supported|
|2021.3.0|[OpenMP Offload Fortran Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/Jupyter/OpenMP-offload-training)|Fortran OpenMP Offload Basics using Jupyter Notebooks|
|2021.3.0|[Optimize TensorFlow pre-trained model for inference](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_InferenceOptimization)|This tutorial will guide you how to optimize a pre-trained model for a better inference performance, and also analyze the model pb files before and after the inference optimizations.|
|2021.3.0|[Shannonization](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/shannonization)|An Intel® FPGA tutorial design that demonstrates an optimization for removing computation from the critical path and improves Fmax/II|
|2021.3.0|[Student's T-test](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/student_t_test)|Performing Student's T-test with Intel® oneMKL Vector Statistics functionality|
|2021.2.1|[Buffered Host-Device Streaming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/buffered_host_streaming)|An FPGA tutorial demonstrating how to stream data between the host and device with multiple buffers|
|2021.2.1|[Fourier Correlation](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/fourier_correlation)|Compute 1D Fourier correlation with Intel® oneMKL|
|2021.2.1|[Host-Device Streaming using USM](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/simple_host_streaming)|An FPGA tutorial demonstrating how to stream data between the host and device with low latency and high throughput|
|2021.2.1|[Lidar Object Detection using PointPillars](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/LidarObjectDetection-PointPillars)|Object detection using a LIDAR point cloud as input. This implementation is based on the paper 'PointPillars: Fast Encoders for Object Detection from Point Clouds'|
|2021.2.1|[STREAM](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Benchmarks/STREAM)|The STREAM is a program that measures memory transfer rates in MB/s for simple computational kernels coded in C|
|2021.1.Gold|[1D Heat Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/1d_HeatTransfer)|The 1D Heat Transfer sample simulates 1D Heat Transfer problem using Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[AWS Pub Sub](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/aws-pub-sub)|This sample uses the Message Broker for AWS* IoT to send and receive messages through an MQTT connection|
|2021.1.Gold|[All Pairs Shortest Paths](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphAlgorithms/all-pairs-shortest-paths)|All Pairs Shortest Paths finds the shortest paths between pairs of vertices in a graph using a parallel blocked algorithm that enables the application to efficiently offload compute intensive work to the GPU.|
|2021.1.Gold|[Analog In](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/analog-in)|Demonstrate how to read an analog voltage value from an input pin using the Eclipse* MRAA library|
|2021.1.Gold|[Azure IoTHub Telemetry](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/azure-iothub-telemetry)|Demonstrate how to send messages from a single device to Microsoft Azure IoT Hub via chosen protocol|
|2021.1.Gold|[Base: Vector Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/vector-add)|This simple sample adds two large vectors in parallel. Provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using simple Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[Bitonic Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/bitonic-sort)|Bitonic Sort using Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[Black Scholes](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/black_scholes)|Black Scholes formula calculation using Intel® oneMKL Vector Math and Random Number Generators|
|2021.1.Gold|[Block Cholesky Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_cholesky_decomposition)|Block Cholesky Decomposition using Intel® oneMKL BLAS and LAPACK|
|2021.1.Gold|[Block LU Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_lu_decomposition)|Block LU Decomposition using Intel® oneMKL BLAS and LAPACK|
|2021.1.Gold|[CMake FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-fpga)|Project Templates - Linux CMake project for FPGA|
|2021.1.Gold|[CMake GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-gpu)|Project Templates - Linux CMake project for GPU|
|2021.1.Gold|[CRR](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/crr)|This sample shows a Binomial Tree Model for Option Pricing using a FPGA-optimized reference design of the Cox-Ross-Rubinstein (CRR) Binomial Tree Model with Greeks for American exercise options|
|2021.1.Gold|[Census end-to-end workload](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/Census)|This sample illustrates using Modin and daal optimized scikit-learn to build and run an end-to-end machine learning workload|
|2021.1.Gold|[Complex Mult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/complex_mult)|This sample computes Complex Number Multiplication|
|2021.1.Gold|[Compute Units](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/compute_units)|Intel® FPGA tutorial showcasing a design pattern to enable the creation of compute units|
|2021.1.Gold|[Computed Tomography](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/computed_tomography)|Reconstruct an image from simulated CT data with Intel® oneMKL|
|2021.1.Gold|[DB](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/db)|An FPGA reference design that demonstrates high-performance Database Query Acceleration on Intel® FPGAs|
|2021.1.Gold|[DPC Reduce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/dpc_reduce)|This sample models transform Reduce in different ways showing capability of Intel® oneAPI|
|2021.1.Gold|[DPC++ Essentials Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/Jupyter/oneapi-essentials-training)|DPC++ Essentials Tutorials using Jupyter Notebooks|
|2021.1.Gold|[DPC++ OpenCL Interoperability Samples](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/OpenCLInterop)|Samples showing DPC++ and OpenCL Interoperability|
|2021.1.Gold|[DPCPP Blur](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/dpcpp-blur)|Sample that shows how to use Intel® Video Processing Library (VPL) and Intel® oneAPI Data Parallel C++ (DPC++) to convert I420 raw video file in to BGRA and blur each frame|
|2021.1.Gold|[DPCPP Interoperability](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/dpcpp_interoperability)|Intel® oneDNN SYCL extensions API programming for both Intel® CPU and GPU|
|2021.1.Gold|[Debugger: Array Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/array-transform)|A small Intel® oneAPI Data Parallel C++ (DPC++) example that is used in the "Get Started Guide" of the Application Debugger to exercise major debugger functionality|
|2021.1.Gold|[Digital In](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/digital-in)|Demonstrate how to read a digital value from an input pin using the Eclipse* MRAA library|
|2021.1.Gold|[Digital Out](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/digital-out)|Demonstrate how to write a digital value to an output pin using the Eclipse* MRAA library|
|2021.1.Gold|[Discrete Cosine Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SpectralMethods/DiscreteCosineTransform)|An image processing algorithm as seen in the JPEG compression standard|
|2021.1.Gold|[Double Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/double_buffering)|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and host-processing to improve system performance|
|2021.1.Gold|[Dynamic Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/dynamic_profiler)|An Intel® FPGA tutorial demonstrating how to use the Intel® FPGA Dynamic Profiler for Intel® oneAPI Data Parallel C++ (DPC++) to dynamically collect performance data and reveal areas for optimization|
|2021.1.Gold|[Explicit Data Movement](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/explicit_data_movement)|An Intel® FPGA tutorial demonstrating an alternative coding style, explicit USM, in which all data movement is controlled explicitly by the author|
|2021.1.Gold|[FPGA Compile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fpga_compile)|Intel® FPGA tutorial introducing how to compile Intel® oneAPI Data Parallel C++ (DPC++) for Intel® FPGA|
|2021.1.Gold|[FPGA Reg](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/fpga_reg)|An Intel® FPGA advanced tutorial demonstrating how to apply the Intel® oneAPI Data Parallel C++ (DPC++) extension INTEL::fpga_reg|
|2021.1.Gold|[Fast Recompile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fast_recompile)|An Intel® FPGA tutorial demonstrating how to separate the compilation of host and device code to save development time|
|2021.1.Gold|[Folder Options DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/folder-options-dpct)|Multi-folder project that illustrates migration of a CUDA project that has files located in multiple folders in a directory tree. Uses the `--in-root` and `--out-root` options to tell the Intel® Data Parallel C++ (DPC++) Compatibility Tool where to locate source code to be migrated|
|2021.1.Gold|[GZIP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/gzip)|Reference design demonstrating high-performance GZIP compression on Intel® FPGA|
|2021.1.Gold|[Gamma Correction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/gamma-correction)|Gamma Correction - a nonlinear operation used to encode and decode the luminance of each image pixel|
|2021.1.Gold|[Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/getting_started)|Basic Intel® oneDNN programming model for both Intel® CPU and GPU|
|2021.1.Gold|[Hello Decode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-decode)|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video decode|
|2021.1.Gold|[Hello Encode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-encode)|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video encode|
|2021.1.Gold|[Hello IoT World](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/hello-iot-world)|This is a basic sample that outputs the classic 'Hello World' message along with the compiler identification string|
|2021.1.Gold|[Hello VPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-vpp)|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform simple video processing|
|2021.1.Gold|[Hello World GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/Hello_World_GPU)|Template 'Hello World' on GPU|
|2021.1.Gold|[Hidden Markov Models](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/hidden-markov-models)|Hidden Markov Models using Intel® oneAPI Data Parallel C++|
|2021.1.Gold|[Histogram](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/histogram)|This sample demonstrates Histogram using Dpstd APIs|
|2021.1.Gold|[IBM Device](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/ibm-device)|This project shows how-to develop a device code using Watson IoT Platform iot-c device client library, connect and interact with Watson IoT Platform Service|
|2021.1.Gold|[ISO2DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso2dfd_dpcpp)|The ISO2DFD sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) Basics using 2D Finite Difference Wave Propagation|
|2021.1.Gold|[ISO3DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso3dfd_dpcpp)|The ISO3DFD Sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) using Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation|
|2021.1.Gold|[ISO3DFD OMP Offload](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/StructuredGrids/iso3dfd_omp_offload)|A Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation using OpenMP* (OMP)|
|2021.1.Gold|[Intel® Low Precision Optimization Tool Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/LPOT-Sample-for-Tensorflow)|This sample illustrates how to run LPOT to quantize the FP32 model trained by Keras on Tensorflow to INT8 model to speed up the inference.|
|2021.1.Gold|[Intel® Modin Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelModin_GettingStarted)|This sample illustrates how to use Modin accelerated Pandas functions and notes the performance gain when compared to standard Pandas functions|
|2021.1.Gold|[Intel® PyTorch Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPyTorch_GettingStarted)|This sample illustrates how to train a PyTorch model and run inference with Intel® oneMKL and Intel® oneDNN|
|2021.1.Gold|[Intel® Python Daal4py Distributed K-Means](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedKMeans)|This sample code illustrates how to train and predict with a distributed K-Means model with the Intel® Distribution of Python using the Python API package Daal4py for Intel® oneDAL|
|2021.1.Gold|[Intel® Python Daal4py Distributed Linear Regression](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedLinearRegression)|This sample code illustrates how to train and predict with a Distributed Linear Regression model with the Intel® Distribution of Python using the Python API package Daal4py for Intel® oneDAL|
|2021.1.Gold|[Intel® Python Daal4py Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_daal4py_GettingStarted)|This sample illustrates how to do Batch Linear Regression using the Python API package Daal4py for Intel® oneDAL|
|2021.1.Gold|[Intel® Python XGBoost Daal4py Prediction](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_daal4pyPrediction)|This sample code illustrates how to analyze the performance benefit of minimal code changes to port pre-trained XGBoost model to daal4py prediction for much faster prediction than XGBoost prediction|
|2021.1.Gold|[Intel® Python XGBoost Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_XGBoost_GettingStarted)|The sample illustrates how to setup and train an XGBoost model on datasets for prediction|
|2021.1.Gold|[Intel® TensorFlow Horovod Multinode Training](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_Horovod_Multinode_Training)|This sample illustrates how to train a TensorFlow model on multiple nodes in a cluster using Horovod|
|2021.1.Gold|[Intel® TensorFlow Model Zoo Inference With FP32 Int8](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8)|This code example illustrates how to run FP32 and Int8 inference on Resnet50 with TensorFlow using Intel® Model Zoo|
|2021.1.Gold|[Intel® Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelTensorFlow_GettingStarted)|This sample illustrates how to train a TensorFlow model and run inference with oneMKL and oneDNN.|
|2021.1.Gold|[Interrupt](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/interrupt)|Demonstrates how to react on an Eclipse* MRAA digital pin event with an ISR (Interrupt Service Routine), which will run independently of the main program flow|
|2021.1.Gold|[Intrinsics](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/Intrinsics)|Demonstrates the Intrinsic functions of the Intel® oneAPI C++ Compiler Classic|
|2021.1.Gold|[Kernel Args Restrict](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/kernel_args_restrict)|Explain the kernel_args_restrict attribute and its effect on the performance of Intel® FPGA kernels|
|2021.1.Gold|[LSU Control](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/lsu_control)|An Intel® FPGA tutorial demonstrating how to configure the load-store units (LSU) in your Intel® oneAPI Data Parallel C++ (DPC++) program using the LSU controls extension|
|2021.1.Gold|[Loop Coalesce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_coalesce)|An Intel® FPGA tutorial demonstrating the loop_coalesce attribute|
|2021.1.Gold|[Loop IVDEP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_ivdep)|An Intel® FPGA tutorial demonstrating the usage of the loop_ivdep attribute|
|2021.1.Gold|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/loop-unroll)|Demonstrates the use of loop unrolling as a simple optimization technique to speed up compute and increase memory access throughput.|
|2021.1.Gold|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_unroll)|An Intel® FPGA tutorial design demonstrating the loop_unroll attribute|
|2021.1.Gold|[Makefile FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-fpga)|Project Templates - Linux Makefile project for FPGA|
|2021.1.Gold|[Makefile GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-gpu)|Project Templates - Linux Makefile project for GPU|
|2021.1.Gold|[Mandelbrot](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/mandelbrot)|The Mandelbrot Set - a fractal example in mathematics|
|2021.1.Gold|[Mandelbrot OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CombinationalLogic/MandelbrotOMP)|Calculates the Mandelbrot Set and outputs a BMP image representation using OpenMP* (OMP)|
|2021.1.Gold|[Matrix Mul](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/matrix_mul)|This sample Multiplies two large Matrices in parallel using Intel® oneAPI Data Parallel C++ (DPC++) and OpenMP* (OMP)|
|2021.1.Gold|[Matrix Mul MKL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/matrix_mul_mkl)|Accelerate Matrix Multiplication with Intel® oneMKL|
|2021.1.Gold|[Matrix Multiply Advisor](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Advisor/matrix_multiply_advisor)|Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|2021.1.Gold|[Matrix Multiply VTune Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/VTuneProfiler/matrix_multiply_vtune)|Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|2021.1.Gold|[Max Interleaving](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/max_interleaving)|An Intel® FPGA tutorial demonstrating the usage of the loop max_interleaving attribute|
|2021.1.Gold|[Memory Attributes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/memory_attributes)|An Intel® FPGA tutorial demonstrating the use of on-chip memory attributes to control memory structures in a Intel® oneAPI Data Parallel C++ (DPC++) program|
|2021.1.Gold|[Merge SPMV](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SparseLinearAlgebra/merge-spmv)|Sparse Matrix Vector sample provides a parallel implementation of a Merge based Sparse Matrix and Vector Multiplication Algorithm using Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[MergeSort OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/GraphTraversal/MergesortOMP)|Classic OpenMP* (OMP) Mergesort algorithm|
|2021.1.Gold|[Monte Carlo European Opt](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_european_opt)|Monte Carlo Simulation of European Options pricing with Intel® oneMKL random number generators|
|2021.1.Gold|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/MapReduce/MonteCarloPi)|Monte Carlo procedure for estimating Pi|
|2021.1.Gold|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_pi)|Estimating Pi with Intel® oneMKL random number generators|
|2021.1.Gold|[N-Body](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/N-BodyMethods/Nbody)|An N-Body simulation is a simulation of a dynamical system of particles, usually under the influence of physical forces, such as gravity. This N-Body sample code is implemented using Intel® oneAPI Data Parallel C++ (DPC++) for CPU and GPU|
|2021.1.Gold|[N-Way Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/n_way_buffering)|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and multi-threaded host-processing to improve system performance|
|2021.1.Gold|[On-Board Blink](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/onboard-blink)|Demonstrates how to blink the on board LED, by writing a digital value to an output pin using the Eclipse* MRAA library|
|2021.1.Gold|[On-Chip Memory Cache](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/onchip_memory_cache)|Intel® FPGA tutorial demonstrating the caching of on-chip memory to reduce loop initiation interval|
|2021.1.Gold|[OpenMP* Primes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/CombinationalLogic/openmp-primes)|Fortran Tutorial - Using OpenMP* (OMP)|
|2021.1.Gold|[OpenMP* Reduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/ParallelPatterns/openmp_reduction)|This sample models OpenMP* (OMP) Reduction in different ways showing capability of Intel® oneAPI|
|2021.1.Gold|[Optimize Inner Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/optimize_inner_loop)|An Intel® FPGA tutorial design demonstrating how to optimize the throughput of inner loops with low trip counts|
|2021.1.Gold|[Optimize Integral](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/optimize-integral)|Fortran Sample - Simple Compiler Optimizations|
|2021.1.Gold|[PWM](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/pwm)|Demonstrate how to use PWM with an output pin using the Eclipse* MRAA library. If the output is connected to a led, its brightness will vary depending on the duty cycle|
|2021.1.Gold|[Particle Diffusion](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/particle-diffusion)|The Particle Diffusion code sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) using a simple (non-optimized) implementation of a Monte Carlo Simulation of the Diffusion of Water Molecules in Tissue|
|2021.1.Gold|[Pipe Array](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/pipe_array)|An Intel® FPGA tutorial showcasing a design pattern to enables the creation of arrays of pipes|
|2021.1.Gold|[Pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/pipes)|How to use Pipes to transfer data between kernels on an Intel® FPGA|
|2021.1.Gold|[Prefix Sum](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/PrefixSum)|Compute Prefix Sum using Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[QRD](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/qrd)|Reference design demonstrating high-performance QR Decomposition (QRD) of complex matrices on a Intel® FPGA|
|2021.1.Gold|[Random Sampling Without Replacement](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/random_sampling_without_replacement)|Multiple simple random sampling without replacement with Intel® oneMKL random number generators|
|2021.1.Gold|[Remove Loop Carried Dependency](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/loop_carried_dependency)|An Intel® FPGA tutorial design demonstrating performance optimization by removing loop carried dependencies|
|2021.1.Gold|[Rodinia NW DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/rodinia-nw-dpct)|Migrate a CUDA project using the Intel® DPCT intercept-build feature to create a compilation database. The compilation database provides compilation options, settings, macro definitions and include paths that the Intel® Data Parallel C++ (DPC++) Compatibility Tool (DPCT) will use during migration of the project|
|2021.1.Gold|[Sepia Filter](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/sepia-filter)|A program that converts an image to Sepia Tone|
|2021.1.Gold|[Simple Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/simple-add)|This simple sample adds two large vectors in parallel and provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[Simple Model](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/simple_model)|Run a simple CNN on both Intel® CPU and GPU with sample C++ codes|
|2021.1.Gold|[Sparse Conjugate Gradient](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/sparse_conjugate_gradient)|Solve Sparse linear systems with the Conjugate Gradient method using Intel® oneMKL sparse BLAS|
|2021.1.Gold|[Speculated Iterations](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/speculated_iterations)|An Intel® FPGA tutorial demonstrating the speculated_iterations attribute|
|2021.1.Gold|[Stable Sort By Key](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/stable_sort_by_key)|This sample models Stable Sort By Key during the sorting of 2 sequences (keys and values) only keys are compared but both keys and values are swapped|
|2021.1.Gold|[System Profiling](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/system_profiling)|An Intel® FPGA tutorial demonstrating how to use the OpenCL* Intercept Layer to improve a design with the double buffering optimization|
|2021.1.Gold|[TBB ASYNC SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-async-sycl)|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Flow Graph asynchronous node and functional node. The Flow Graph asynchronous node uses SYCL to implement calculations on GPU while the functional node does CPU part of calculations. This TBB ASYNC SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|2021.1.Gold|[TBB Resumable Tasks SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-resumable-tasks-sycl)|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Resumable Task and parallel_for. The Intel® oneTBB resumable task uses SYCL to implement calculations on GPU while the parallel_for algorithm does CPU part of calculations. This TBB Resumable Tasks SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|2021.1.Gold|[TBB Task SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-task-sycl)|This sample illustrates how 2 Intel® oneTBB tasks can execute similar computational kernels with one task executing SYCL code and another one executing the Intel® oneTBB code. This TBB Task SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|2021.1.Gold|[Triangular Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/triangular_loop)|An Intel® FPGA tutorial demonstrating an advanced optimization technique for triangular loops|
|2021.1.Gold|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/tutorials)|Intel® oneCCL Tutorials|
|2021.1.Gold|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/tutorials)|Intel® oneDNN Tutorials|
|2021.1.Gold|[UP2 LEDS](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/up2-leds)|This sample shows how to use the LED class and APIs of the Eclipse* MRAA library. It is intended to run on the UP Squared board, and will utilize the 4 built-in color LEDs located under the Ethernet ports. No additional hardware is required|
|2021.1.Gold|[Use Library](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/use_library)|An Intel® FPGA Tutorial demonstrating how to create Intel® FPGA libraries and to incorporate them in a Intel® oneAPI Data Parallel C++ (DPC++) project|
|2021.1.Gold|[Vector Add DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/vector-add-dpct)|Simple project to illustrate the basic migration of CUDA code. Use this sample to ensure your environment is configured correctly and to understand the basics of migrating existing CUDA projects to Intel® oneAPI Data Parallel C++ (DPC++)|
|2021.1.Gold|[Vectorize VecMatMult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/vectorize-vecmatmult)|Fortran Tutorial - Using Auto Vectorization|
|2021.1.Gold|[Zero Copy Data Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/zero_copy_data_transfer)|An Intel® FPGA tutorial demonstrating zero-copy host memory using the SYCL restricted Unified Shared Memory (USM) model|
|2021.1.Gold|[oneCCL Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/oneCCL_Getting_Started)|Basic Intel® oneCCL programming model for both Intel® CPU and GPU|
