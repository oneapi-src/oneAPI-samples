## oneAPI Code Samples

|Code Sample Name|Supported Intel&reg; Architecture(s)|Description|
|-----------------------|----------------------|---------------------|
|[1D Heat Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/1d_HeatTransfer)|['CPU', 'GPU']|The 1D Heat Transfer sample simulates 1D Heat Transfer problem using Intel® oneAPI Data Parallel C++ (DPC++)|
|[AWS Pub Sub](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/aws-pub-sub)|['CPU']|This sample uses the Message Broker for AWS* IoT to send and receive messages through an MQTT connection|
|[All Pairs Shortest Paths](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphAlgorithms/all-pairs-shortest-paths)|['CPU', 'GPU']|All Pairs Shortest Paths finds the shortest paths between pairs of vertices in a graph using a parallel blocked algorithm that enables the application to efficiently offload compute intensive work to the GPU.|
|[Analog In](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/analog-in)|['CPU']|Demonstrate how to read an analog voltage value from an input pin using the Eclipse* MRAA library|
|[Azure IoTHub Telemetry](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/azure-iothub-telemetry)|['CPU']|Demonstrate how to send messages from a single device to Microsoft Azure IoT Hub via chosen protocol|
|[Base: Vector Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/vector-add)|['CPU', 'GPU', 'FPGA']|This simple sample adds two large vectors in parallel. Provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using simple Intel® oneAPI Data Parallel C++ (DPC++)|
|[Bitonic Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/bitonic-sort)|['CPU', 'GPU']|Bitonic Sort using Intel® oneAPI Data Parallel C++ (DPC++)|
|[Black Scholes](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/black_scholes)|['CPU', 'GPU']|Black Scholes formula calculation using Intel® oneMKL Vector Math and Random Number Generators|
|[Block Cholesky Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_cholesky_decomposition)|['CPU', 'GPU']|Block Cholesky Decomposition using Intel® oneMKL BLAS and LAPACK|
|[Block LU Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_lu_decomposition)|['CPU', 'GPU']|Block LU Decomposition using Intel® oneMKL BLAS and LAPACK|
|[Buffered Host-Device Streaming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/buffered_host_streaming)|['FPGA']|An FPGA tutorial demonstrating how to stream data between the host and device with multiple buffers|
|[CMake FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-fpga)|['FPGA']|Project Templates - Linux CMake project for FPGA|
|[CMake GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-gpu)|['GPU']|Project Templates - Linux CMake project for GPU|
|[CRR](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/crr)|['FPGA']|This sample shows a Binomial Tree Model for Option Pricing using a FPGA-optimized reference design of the Cox-Ross-Rubinstein (CRR) Binomial Tree Model with Greeks for American exercise options|
|[Census end-to-end workload](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/Census)|['CPU']|This sample illustrates using Modin and daal optimized scikit-learn to build and run an end-to-end machine learning workload|
|[Complex Mult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/complex_mult)|['CPU', 'GPU']|This sample computes Complex Number Multiplication|
|[Compute Units](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/compute_units)|['FPGA']|Intel® FPGA tutorial showcasing a design pattern to enable the creation of compute units|
|[Computed Tomography](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/computed_tomography)|['CPU', 'GPU']|Reconstruct an image from simulated CT data with Intel® oneMKL|
|[DB](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/db)|['FPGA']|An FPGA reference design that demonstrates high-performance Database Query Acceleration on Intel® FPGAs|
|[DPC Reduce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/dpc_reduce)|['CPU', 'GPU']|This sample models transform Reduce in different ways showing capability of Intel® oneAPI|
|[DPC++ Essentials Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/Jupyter/oneapi-essentials-training)|['CPU', 'GPU']|DPC++ Essentials Tutorials using Jupyter Notebooks|
|[DPC++ OpenCL Interoperability Samples](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/OpenCLInterop)|['CPU', 'GPU']|Samples showing DPC++ and OpenCL Interoperability|
|[DPCPP Blur](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/dpcpp-blur)|['CPU', 'GPU']|Sample that shows how to use Intel® Video Processing Library (VPL) and Intel® oneAPI Data Parallel C++ (DPC++) to convert I420 raw video file in to BGRA and blur each frame|
|[DPCPP Interoperability](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/dpcpp_interoperability)|['CPU', 'GPU']|Intel® oneDNN SYCL extensions API programming for both Intel® CPU and GPU|
|[Debugger: Array Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/array-transform)|['CPU', 'GPU']|A small Intel® oneAPI Data Parallel C++ (DPC++) example that is used in the "Get Started Guide" of the Application Debugger to exercise major debugger functionality|
|[Digital In](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/digital-in)|['CPU']|Demonstrate how to read a digital value from an input pin using the Eclipse* MRAA library|
|[Digital Out](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/digital-out)|['CPU']|Demonstrate how to write a digital value to an output pin using the Eclipse* MRAA library|
|[Discrete Cosine Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SpectralMethods/DiscreteCosineTransform)|['CPU', 'GPU']|An image processing algorithm as seen in the JPEG compression standard|
|[Double Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/double_buffering)|['FPGA']|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and host-processing to improve system performance|
|[Dynamic Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/dynamic_profiler)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the Intel® FPGA Dynamic Profiler for Intel® oneAPI Data Parallel C++ (DPC++) to dynamically collect performance data and reveal areas for optimization|
|[Explicit Data Movement](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/explicit_data_movement)|['FPGA']|An Intel® FPGA tutorial demonstrating an alternative coding style, explicit USM, in which all data movement is controlled explicitly by the author|
|[FPGA Compile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fpga_compile)|['FPGA']|Intel® FPGA tutorial introducing how to compile Intel® oneAPI Data Parallel C++ (DPC++) for Intel® FPGA|
|[FPGA Reg](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/fpga_reg)|['FPGA']|An Intel® FPGA advanced tutorial demonstrating how to apply the Intel® oneAPI Data Parallel C++ (DPC++) extension ext::intel::fpga_reg|
|[Fast Recompile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fast_recompile)|['FPGA']|An Intel® FPGA tutorial demonstrating how to separate the compilation of host and device code to save development time|
|[Folder Options DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/folder-options-dpct)|['CPU']|Multi-folder project that illustrates migration of a CUDA project that has files located in multiple folders in a directory tree. Uses the `--in-root` and `--out-root` options to tell the Intel® Data Parallel C++ (DPC++) Compatibility Tool where to locate source code to be migrated|
|[Fourier Correlation](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/fourier_correlation)|['CPU', 'GPU']|Compute 1D Fourier correlation with Intel® oneMKL|
|[GZIP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/gzip)|['FPGA']|Reference design demonstrating high-performance GZIP compression on Intel® FPGA|
|[Gamma Correction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/gamma-correction)|['CPU', 'GPU']|Gamma Correction - a nonlinear operation used to encode and decode the luminance of each image pixel|
|[Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/getting_started)|['CPU', 'GPU']|Basic Intel® oneDNN programming model for both Intel® CPU and GPU|
|[Hello Decode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-decode)|['CPU', 'GPU']|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video decode|
|[Hello Encode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-encode)|['CPU', 'GPU']|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video encode|
|[Hello IoT World](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/hello-iot-world)|['CPU']|This is a basic sample that outputs the classic 'Hello World' message along with the compiler identification string|
|[Hello VPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-vpp)|['CPU', 'GPU']|Sample that shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform simple video processing|
|[Hello World GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/Hello_World_GPU)|['GPU']|Template 'Hello World' on GPU|
|[Hidden Markov Models](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/hidden-markov-models)|['CPU', 'GPU']|Hidden Markov Models using Intel® oneAPI Data Parallel C++|
|[Histogram](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/histogram)|['CPU', 'GPU']|This sample demonstrates Histogram using Dpstd APIs|
|[Host-Device Streaming using USM](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/simple_host_streaming)|['FPGA']|An FPGA tutorial demonstrating how to stream data between the host and device with low latency and high throughput|
|[IBM Device](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/ibm-device)|['CPU']|This project shows how-to develop a device code using Watson IoT Platform iot-c device client library, connect and interact with Watson IoT Platform Service|
|[IO streaming with DPC++ IO pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/io_streaming)|['FPGA']|An FPGA tutorial describing how to stream data to and from DPC++ IO pipes.|
|[ISO2DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso2dfd_dpcpp)|['CPU', 'GPU']|The ISO2DFD sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) Basics using 2D Finite Difference Wave Propagation|
|[ISO3DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso3dfd_dpcpp)|['CPU']|The ISO3DFD Sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) using Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation|
|[ISO3DFD OMP Offload](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/StructuredGrids/iso3dfd_omp_offload)|['GPU']|A Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation using OpenMP* (OMP)|
|[Intel® Low Precision Optimization Tool Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/LPOT-Sample-for-Tensorflow)|['CPU']|This sample illustrates how to run LPOT to quantize the FP32 model trained by Keras on Tensorflow to INT8 model to speed up the inference.|
|[Intel® Modin Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelModin_GettingStarted)|['CPU']|This sample illustrates how to use Modin accelerated Pandas functions and notes the performance gain when compared to standard Pandas functions|
|[Intel® PyTorch Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPyTorch_GettingStarted)|['CPU']|This sample illustrates how to train a PyTorch model and run inference with Intel® oneMKL and Intel® oneDNN|
|[Intel® Python Daal4py Distributed K-Means](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedKMeans)|['CPU']|This sample code illustrates how to train and predict with a distributed K-Means model with the Intel® Distribution of Python using the Python API package Daal4py for Intel® oneDAL|
|[Intel® Python Daal4py Distributed Linear Regression](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedLinearRegression)|['CPU']|This sample code illustrates how to train and predict with a Distributed Linear Regression model with the Intel® Distribution of Python using the Python API package Daal4py for Intel® oneDAL|
|[Intel® Python Daal4py Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_daal4py_GettingStarted)|['CPU']|This sample illustrates how to do Batch Linear Regression using the Python API package Daal4py for Intel® oneDAL|
|[Intel® Python XGBoost Daal4py Prediction](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_daal4pyPrediction)|['CPU']|This sample code illustrates how to analyze the performance benefit of minimal code changes to port pre-trained XGBoost model to daal4py prediction for much faster prediction than XGBoost prediction|
|[Intel® Python XGBoost Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_XGBoost_GettingStarted)|['CPU']|The sample illustrates how to setup and train an XGBoost model on datasets for prediction|
|[Intel® Python XGBoost Performance](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_Performance)|['CPU']|This sample code illustrates how to analyze the performance benefit from using Intel optimizations upstreamed by Intel to latest XGBoost compared to un-optimized XGBoost 0.81 |
|[Intel® TensorFlow Horovod Multinode Training](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_Horovod_Multinode_Training)|['CPU']|This sample illustrates how to train a TensorFlow model on multiple nodes in a cluster using Horovod|
|[Intel® TensorFlow Model Zoo Inference With FP32 Int8](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8)|['CPU']|This code example illustrates how to run FP32 and Int8 inference on Resnet50 with TensorFlow using Intel® Model Zoo|
|[Intel® Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelTensorFlow_GettingStarted)|['CPU']|This sample illustrates how to train a TensorFlow model and run inference with oneMKL and oneDNN.|
|[Interrupt](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/interrupt)|['CPU']|Demonstrates how to react on an Eclipse* MRAA digital pin event with an ISR (Interrupt Service Routine), which will run independently of the main program flow|
|[Intrinsics](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/Intrinsics)|['CPU']|Demonstrates the Intrinsic functions of the Intel® oneAPI C++ Compiler Classic|
|[Jacobi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/jacobi)|['CPU', 'GPU']|A small Intel® oneAPI Data Parallel C++ (DPC++) example which solves a harcoded linear system with Jacobi iteration. The sample includes two versions of the same program: with and without bugs.|
|[Kernel Args Restrict](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/kernel_args_restrict)|['FPGA']|Explain the kernel_args_restrict attribute and its effect on the performance of Intel® FPGA kernels|
|[LSU Control](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/lsu_control)|['FPGA']|An Intel® FPGA tutorial demonstrating how to configure the load-store units (LSU) in your Intel® oneAPI Data Parallel C++ (DPC++) program using the LSU controls extension|
|[Lidar Object Detection using PointPillars](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/LidarObjectDetection-PointPillars)|['CPU', 'GPU']|Object detection using a LIDAR point cloud as input. This implementation is based on the paper 'PointPillars: Fast Encoders for Object Detection from Point Clouds'|
|[Loop Coalesce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_coalesce)|['FPGA']|An Intel® FPGA tutorial demonstrating the loop_coalesce attribute|
|[Loop IVDEP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_ivdep)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the loop_ivdep attribute|
|[Loop Initiation Interval](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_initiation_interval)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the initiation_interval attribute|
|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/loop-unroll)|['CPU', 'GPU']|Demonstrates the use of loop unrolling as a simple optimization technique to speed up compute and increase memory access throughput.|
|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_unroll)|['FPGA']|An Intel® FPGA tutorial design demonstrating the loop_unroll attribute|
|[MVDR Beamforming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/mvdr_beamforming)|['FPGA']|A reference design demonstrating a high-performance streaming MVDR beamformer|
|[Makefile FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-fpga)|['FPGA']|Project Templates - Linux Makefile project for FPGA|
|[Makefile GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-gpu)|['GPU']|Project Templates - Linux Makefile project for GPU|
|[Mandelbrot](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/mandelbrot)|['CPU', 'GPU']|The Mandelbrot Set - a fractal example in mathematics|
|[Mandelbrot OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CombinationalLogic/MandelbrotOMP)|['CPU', 'GPU']|Calculates the Mandelbrot Set and outputs a BMP image representation using OpenMP* (OMP)|
|[Matrix Mul](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/matrix_mul)|['CPU', 'GPU']|This sample Multiplies two large Matrices in parallel using Intel® oneAPI Data Parallel C++ (DPC++) and OpenMP* (OMP)|
|[Matrix Mul MKL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/matrix_mul_mkl)|['CPU', 'GPU']|Accelerate Matrix Multiplication with Intel® oneMKL|
|[Matrix Multiply Advisor](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Advisor/matrix_multiply_advisor)|['CPU', 'GPU']|Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|[Matrix Multiply VTune Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/VTuneProfiler/matrix_multiply_vtune)|['CPU', 'GPU']|Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|[Max Interleaving](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/max_interleaving)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the loop max_interleaving attribute|
|[Memory Attributes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/memory_attributes)|['FPGA']|An Intel® FPGA tutorial demonstrating the use of on-chip memory attributes to control memory structures in a Intel® oneAPI Data Parallel C++ (DPC++) program|
|[Merge SPMV](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SparseLinearAlgebra/merge-spmv)|['CPU', 'GPU']|Sparse Matrix Vector sample provides a parallel implementation of a Merge based Sparse Matrix and Vector Multiplication Algorithm using Intel® oneAPI Data Parallel C++ (DPC++)|
|[Merge Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/merge_sort)|['FPGA']|A Reference design demonstrating merge sort on an Intel® FPGA|
|[MergeSort OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/GraphTraversal/MergesortOMP)|['CPU']|Classic OpenMP* (OMP) Mergesort algorithm|
|[Monte Carlo European Opt](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_european_opt)|['CPU', 'GPU']|Monte Carlo Simulation of European Options pricing with Intel® oneMKL random number generators|
|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/MapReduce/MonteCarloPi)|['CPU', 'GPU']|Monte Carlo procedure for estimating Pi|
|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_pi)|['CPU', 'GPU']|Estimating Pi with Intel® oneMKL random number generators|
|[N-Body](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/N-BodyMethods/Nbody)|['CPU', 'GPU']|An N-Body simulation is a simulation of a dynamical system of particles, usually under the influence of physical forces, such as gravity. This N-Body sample code is implemented using Intel® oneAPI Data Parallel C++ (DPC++) for CPU and GPU|
|[N-Way Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/n_way_buffering)|['FPGA']|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and multi-threaded host-processing to improve system performance|
|[On-Board Blink](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/onboard-blink)|['CPU']|Demonstrates how to blink the on board LED, by writing a digital value to an output pin using the Eclipse* MRAA library|
|[On-Chip Memory Cache](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/onchip_memory_cache)|['FPGA']|Intel® FPGA tutorial demonstrating the caching of on-chip memory to reduce loop initiation interval|
|[OpenMP Offload C++ Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/Jupyter/OpenMP-offload-training)|['CPU', 'GPU']|C++ OpenMP Offload Basics using Jupyter Notebooks|
|[OpenMP Offload Feature Samples](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/OpenMP_Offload_Features)|['CPU', 'GPU']|Samples showing new OpenMP Offload features supported|
|[OpenMP Offload Fortran Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/Jupyter/OpenMP-offload-training)|['CPU', 'GPU']|Fortran OpenMP Offload Basics using Jupyter Notebooks|
|[OpenMP* Primes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/CombinationalLogic/openmp-primes)|['CPU']|Fortran Tutorial - Using OpenMP* (OMP)|
|[OpenMP* Reduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/ParallelPatterns/openmp_reduction)|['CPU', 'GPU']|This sample models OpenMP* (OMP) Reduction in different ways showing capability of Intel® oneAPI|
|[Optimize Inner Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/optimize_inner_loop)|['FPGA']|An Intel® FPGA tutorial design demonstrating how to optimize the throughput of inner loops with low trip counts|
|[Optimize Integral](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/optimize-integral)|['CPU']|Fortran Sample - Simple Compiler Optimizations|
|[Optimize TensorFlow pre-trained model for inference](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_InferenceOptimization)|['CPU']|This tutorial will guide you how to optimize a pre-trained model for a better inference performance, and also analyze the model pb files before and after the inference optimizations.|
|[PWM](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/pwm)|['CPU']|Demonstrate how to use PWM with an output pin using the Eclipse* MRAA library. If the output is connected to a led, its brightness will vary depending on the duty cycle|
|[Particle Diffusion](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/particle-diffusion)|['CPU', 'GPU']|The Particle Diffusion code sample illustrates Intel® oneAPI Data Parallel C++ (DPC++) using a simple (non-optimized) implementation of a Monte Carlo Simulation of the Diffusion of Water Molecules in Tissue|
|[Pipe Array](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/pipe_array)|['FPGA']|An Intel® FPGA tutorial showcasing a design pattern to enables the creation of arrays of pipes|
|[Pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/pipes)|['FPGA']|How to use Pipes to transfer data between kernels on an Intel® FPGA|
|[Prefix Sum](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/PrefixSum)|['CPU', 'GPU']|Compute Prefix Sum using Intel® oneAPI Data Parallel C++ (DPC++)|
|[Private Copies](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/private_copies)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the private_copies attribute to trade off the resource use and the throughput of a DPC++ FPGA program|
|[QRD](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/qrd)|['FPGA']|Reference design demonstrating high-performance QR Decomposition (QRD) of complex matrices on a Intel® FPGA|
|[Random Sampling Without Replacement](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/random_sampling_without_replacement)|['CPU', 'GPU']|Multiple simple random sampling without replacement with Intel® oneMKL random number generators|
|[Remove Loop Carried Dependency](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/loop_carried_dependency)|['FPGA']|An Intel® FPGA tutorial design demonstrating performance optimization by removing loop carried dependencies|
|[Rodinia NW DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/rodinia-nw-dpct)|['CPU']|Migrate a CUDA project using the Intel® DPCT intercept-build feature to create a compilation database. The compilation database provides compilation options, settings, macro definitions and include paths that the Intel® Data Parallel C++ (DPC++) Compatibility Tool (DPCT) will use during migration of the project|
|[STREAM](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Benchmarks/STREAM)|['CPU', 'GPU']|The STREAM is a program that measures memory transfer rates in MB/s for simple computational kernels coded in C|
|[Sepia Filter](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/sepia-filter)|['CPU', 'GPU']|A program that converts an image to Sepia Tone|
|[Shannonization](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/shannonization)|['FPGA']|An Intel® FPGA tutorial design that demonstrates an optimization for removing computation from the critical path and improves Fmax/II|
|[Simple Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/simple-add)|['CPU', 'GPU', 'FPGA']|This simple sample adds two large vectors in parallel and provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using Intel® oneAPI Data Parallel C++ (DPC++)|
|[Simple Model](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/simple_model)|['CPU', 'GPU']|Run a simple CNN on both Intel® CPU and GPU with sample C++ codes|
|[Sparse Conjugate Gradient](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/sparse_conjugate_gradient)|['CPU', 'GPU']|Solve Sparse linear systems with the Conjugate Gradient method using Intel® oneMKL sparse BLAS|
|[Speculated Iterations](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/speculated_iterations)|['FPGA']|An Intel® FPGA tutorial demonstrating the speculated_iterations attribute|
|[Stable Sort By Key](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/stable_sort_by_key)|['CPU', 'GPU']|This sample models Stable Sort By Key during the sorting of 2 sequences (keys and values) only keys are compared but both keys and values are swapped|
|[Stall Enable](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/stall_enable)|['FPGA']|An Intel® FPGA tutorial demonstrating the use_stall_enable_clusters attribute|
|[Student's T-test](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/student_t_test)|['CPU', 'GPU']|Performing Student's T-test with Intel® oneMKL Vector Statistics functionality|
|[System Profiling](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/system_profiling)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the OpenCL* Intercept Layer to improve a design with the double buffering optimization|
|[TBB ASYNC SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-async-sycl)|['CPU', 'GPU']|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Flow Graph asynchronous node and functional node. The Flow Graph asynchronous node uses SYCL to implement calculations on GPU while the functional node does CPU part of calculations. This TBB ASYNC SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[TBB Resumable Tasks SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-resumable-tasks-sycl)|['CPU', 'GPU']|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Resumable Task and parallel_for. The Intel® oneTBB resumable task uses SYCL to implement calculations on GPU while the parallel_for algorithm does CPU part of calculations. This TBB Resumable Tasks SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[TBB Task SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-task-sycl)|['CPU', 'GPU']|This sample illustrates how 2 Intel® oneTBB tasks can execute similar computational kernels with one task executing SYCL code and another one executing the Intel® oneTBB code. This TBB Task SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[Triangular Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/triangular_loop)|['FPGA']|An Intel® FPGA tutorial demonstrating an advanced optimization technique for triangular loops|
|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/tutorials)|['CPU', 'GPU']|Intel® oneCCL Tutorials|
|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/tutorials)|['CPU', 'GPU']|Intel® oneDNN Tutorials|
|[UP2 LEDS](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/up2-leds)|['CPU']|This sample shows how to use the LED class and APIs of the Eclipse* MRAA library. It is intended to run on the UP Squared board, and will utilize the 4 built-in color LEDs located under the Ethernet ports. No additional hardware is required|
|[Use Library](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/use_library)|['FPGA']|An Intel® FPGA Tutorial demonstrating how to create Intel® FPGA libraries and to incorporate them in a Intel® oneAPI Data Parallel C++ (DPC++) project|
|[Vector Add DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/vector-add-dpct)|['CPU']|Simple project to illustrate the basic migration of CUDA code. Use this sample to ensure your environment is configured correctly and to understand the basics of migrating existing CUDA projects to Intel® oneAPI Data Parallel C++ (DPC++)|
|[Vectorize VecMatMult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/vectorize-vecmatmult)|['CPU']|Fortran Tutorial - Using Auto Vectorization|
|[Zero Copy Data Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/zero_copy_data_transfer)|['FPGA']|An Intel® FPGA tutorial demonstrating zero-copy host memory using the SYCL restricted Unified Shared Memory (USM) model|
|[oneCCL Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/oneCCL_Getting_Started)|['CPU', 'GPU']|Basic Intel® oneCCL programming model for both Intel® CPU and GPU|
Total Samples: 138

Report Generated on:  August 23, 2021
This doc was created on: August 23, 2021
This doc was created on: August 23, 2021