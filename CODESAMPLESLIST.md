## oneAPI Code Samples

This Page is a complete list of oneAPI Code Samples, sorted by Alphabetical order

|Code Sample Name|Supported Intel&reg; Architecture(s)|Description|
|-----------------------|----------------------|---------------------|
|[1D Heat Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/1d_HeatTransfer)|['CPU', 'GPU']|The 1D Heat Transfer sample simulates 1D Heat Transfer problem using Data Parallel C++ (DPC++)|
|[AC Int](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/ac_int)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the Algorithmic C Integer (AC Int) |
|[Adaptive Noise Reduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/anr)|['FPGA']|A highly optimized adaptive noise reduction (ANR) algorithm on an FPGA.|
|[All Pairs Shortest Paths](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphAlgorithms/all-pairs-shortest-paths)|['CPU', 'GPU']|All Pairs Shortest Paths finds the shortest paths between pairs of vertices in a graph using a parallel blocked algorithm that enables the application to efficiently offload compute intensive work to the GPU.|
|[Autorun kernels](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/autorun)|['FPGA']|Intel® FPGA tutorial demonstrating autorun kernels|
|[AWS Pub Sub](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/aws-pub-sub)|['CPU']|This sample uses the Message Broker for AWS* IoT to send and receive messages through an MQTT connection|
|[Azure IoTHub Telemetry](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/azure-iothub-telemetry)|['CPU']|Demonstrate how to send messages from a single device to Microsoft Azure IoT Hub via chosen protocol|
|[Base: Vector Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/vector-add)|['CPU', 'GPU', 'FPGA']|This simple sample adds two large vectors in parallel. Provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using simple Data Parallel C++ (DPC++)|
|[Bitonic Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/bitonic-sort)|['CPU', 'GPU']|Bitonic Sort using Data Parallel C++ (DPC++)|
|[Black Scholes](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/black_scholes)|['CPU', 'GPU']|Black Scholes formula calculation using Intel® oneMKL Vector Math and Random Number Generators|
|[Block Cholesky Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_cholesky_decomposition)|['CPU', 'GPU']|Block Cholesky Decomposition using Intel® oneMKL BLAS and LAPACK|
|[Block LU Decomposition](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/block_lu_decomposition)|['CPU', 'GPU']|Block LU Decomposition using Intel® oneMKL BLAS and LAPACK|
|[Buffered Host-Device Streaming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/buffered_host_streaming)|['FPGA']|An FPGA tutorial demonstrating how to stream data between the host and device with multiple buffers|
|[Census](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/Census)|['CPU']|This sample illustrates the use of Intel® Distribution of Modin* and Intel Extension for Scikit-learn to build and run an end-to-end machine learning workload|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 01 - Introduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch01_intro)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_1_1_hello.cpp - Hello data-parallel programming  <br>- Fig_1_3_race.cpp - Adding a race condition to illustrate a point about being asynchronous  <br>- Fig_1_4_lambda.cpp - Lambda function in C++ code  <br>- Fig_1_6_functor.cpp - Function object instead of a lambda (more on this in Chapter 10)|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 02 - Where Code Executes](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch02_where_code_runs)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_2_2_simple_program.cpp - Simple SYCL program   <br>- Fig_2_7_implicit_default_selector.cpp - Implicit default device selector through trivial construction of a queue   <br>- Fig_2_9_host_selector.cpp - Selecting the host device using the host_selector class  <br>- Fig_2_10_cpu_selector.cpp - CPU device selector example  <br>- Fig_2_12_multiple_selectors.cpp  - Example device identification output from various classes of device selectors and demonstration that device selectors can be used for cons  <br>- Fig_2_13_gpu_plus_fpga.cpp - Creating queues to both GPU and FPGA devices   <br>- Fig_2_15_custom_selector.cpp - Custom selector for Intel Arria FPGA device   <br>- Fig_2_18_simple_device_code.cpp - Submission of device code   <br>- Fig_2_22_simple_device_code_2.cpp - Submission of device code   <br>- Fig_2_23_fallback.cpp - Fallback queue example|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 03 - Data Management](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch03_data_management)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_3_4_usm_explicit_data_movement.cpp - USM explicit data movement   <br>- Fig_3_5_usm_implicit_data_movement.cpp - USM implicit data movement   <br>- Fig_3_6_buffers_and_accessors.cpp - Buffers and accessors   <br>- Fig_3_10_in_order.cpp - In-order queue usage   <br>- Fig_3_11_depends_on.cpp - Using events and depends_on  <br>- Fig_3_13_read_after_write.cpp - Read-after-Write   <br>- Fig_3_15_write_after_read_and_write_after_write.cpp - Write-after-Read and Write-after-Write |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 04 - Expresssing Parallelism](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch04_expressing_parallelism)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_4_5_vector_add.cpp - Expressing a vector addition kernel with parallel_for  <br>- Fig_4_6_matrix_add.cpp - Expressing a matrix addition kernel with parallel_for  <br>- Fig_4_7_basic_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel for square matrices, with parallel_for  <br>- Fig_4_13_nd_range_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with ND-range parallel_for  <br>- Fig_4_20_hierarchical_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with hierarchical parallelism  <br>- Fig_4_22_hierarchical_logical_matrix_multiply.cpp - Expressing a naïve matrix multiplication kernel with hierarchical parallelism and a logical range|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 05 - Error Handling](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch05_error_handling)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_5_1_async_task_graph.cpp - Separation of host program and task graph executions  <br>- Fig_5_2_sync_error.cpp - Creating a synchronous error  <br>- Fig_5_3_async_error.cpp - Creating an asynchronous error  <br>- Fig_5_4_unhandled_exception.cpp - Unhandled exception in C++  <br>- Fig_5_5_terminate.cpp - std::terminate is called when a SYCL asynchronous exception isn’t handled  <br>- Fig_5_6_catch_snip.cpp - Pattern to catch sycl::exception specifically  <br>- Fig_5_7_catch.cpp - Pattern to catch exceptions from a block of code  <br>- Fig_5_8_lambda_handler.cpp - Example asynchronous handler implementation defined as a lambda  <br>- Fig_5_9_default_handler_proxy.cpp - Example of how the default asynchronous handler behaves |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 06 - Unified Shared Memory](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch06_unified_shared_memory)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_6_5_allocation_styles.cpp - Three styles for allocation  <br>- Fig_6_6_usm_explicit_data_movement.cpp - USM explicit data movement example  <br>- Fig_6_7_usm_implicit_data_movement.cpp - USM implicit data movement example  <br>- Fig_6_8_prefetch_memadvise.cpp - Fine-grained control via prefetch and mem_advise  <br>- Fig_6_9_queries.cpp - Queries on USM pointers and devices |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 07 - Buffers](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch07_buffers)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_7_2_3_4_creating_buffers.cpp - Creating buffers, Part 1 - Figure 7-3. Creating buffers, Part 2  - Figure 7-4. Creating buffers, Part 3  <br>- Fig_7_5_buffer_properties.cpp - Buffer properties  <br>- Fig_7_8_accessors_simple.cpp - Simple accessor creation  <br>- Fig_7_10_accessors.cpp - Accessor creation with specified usage|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 08 - Scheduling Kernals and Data Movement](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch08_graph_scheduling)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_8_3_linear_dependence_in_order.cpp - Linear dependence chain with in-order queues  <br>- Fig_8_4_linear_dependence_events.cpp - Linear dependence chain with events  <br>- Fig_8_5_linear_dependence_buffers.cpp - Linear dependence chain with buffers and accessors  <br>- Fig_8_6_y_in_order.cpp - Y pattern with in-order queues  <br>- Fig_8_7_y_events.cpp - Y pattern with events  <br>- Fig_8_8_y_buffers.cpp - Y pattern with accessors|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 09 - Communication and Synchronization](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch09_work_item_communication)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_9_4_naive_matrix_multiplication.cpp - The naïve matrix multiplication kernel from Chapter 4  <br>- Fig_9_7_local_accessors.cpp - Declaring and using local accessors  <br>- Fig_9_8_ndrange_tiled_matrix_multiplication.cpp - Expressing a tiled matrix multiplication kernel with an ND-range parallel_for and work-group local memory  <br>- Fig_9_9_local_hierarchical.cpp - Hierarchical kernel with a local memory variable  <br>- Fig_9_10_hierarchical_tiled_matrix_multiplication.cpp - A tiled matrix multiplication kernel implemented as a hierarchical kernel  <br>- Fig_9_11_sub_group_barrier.cpp - Querying and using the sub_group class  <br>- Fig_9_13_matrix_multiplication_broadcast.cpp - Matrix multiplication kernel includes a broadcast operation  <br>- Fig_9_14_ndrange_sub_group_matrix_multiplication.cpp - Tiled matrix multiplication kernel expressed with ND-range parallel_for and sub-group collective functions|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 10 - Defining Kernels](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch10_expressing_kernels)|['CPU', 'GPU']|Collection of Code samples for the chapter <br>- Fig_10_2_kernel_lambda.cpp - Kernel defined using a lambda expression  <br>- Fig_10_3_optional_kernel_lambda_elements.cpp - More elements of a kernel lambda expression, including optional elements  <br>- Fig_10_4_named_kernel_lambda.cpp - Naming kernel lambda expressions  <br>- Fig_10_5_unnamed_kernel_lambda.cpp - Using unnamed kernel lambda expressions  <br>- Fig_10_6_kernel_functor.cpp - Kernel as a named function object  <br>- Fig_10_8_opencl_object_interop.cpp - Kernel created from an OpenCL kernel object|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 11 - Vectors](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch11_vectors)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_11_6_load_store.cpp - Use of load and store member functions.  <br>- Fig_11_7_swizzle_vec.cpp - Example of using the __swizzled_vec__ class  <br>- Fig_11_8_vector_exec.cpp - Vector execution example |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 12 - Device Information](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch12_device_information)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_12_1_assigned_device.cpp - Device we have been assigned by default  <br>- Fig_12_2_try_catch.cpp - Using try-catch to select a GPU device if possible, host device if not  <br>- Fig_12_3_device_selector.cpp - Custom device selector—our preferred solution  <br>- Fig_12_4_curious.cpp - Simple use of device query mechanisms: curious.cpp  <br>- Fig_12_6_very_curious.cpp - More detailed use of device query mechanisms: verycurious.cpp  <br>- Fig_12_7_invocation_parameters.cpp - Fetching parameters that can be used to shape a kernel|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 13 - Practical Tips](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch13_practical_tips)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_13_4_stream.cpp - sycl::stream  <br>- Fig_13_6_common_buffer_pattern.cpp - Common pattern—buffer creation from a host allocation  <br>- Fig_13_7_common_pattern_bug.cpp - Common bug: Reading data directly from host allocation during buffer lifetime  <br>- Fig_13_8_host_accessor.cpp - Recommendation: Use a host accessor to read kernel result  <br>- Fig_13_9_host_accessor_for_init.cpp - Recommendation: Use host accessors for buffer initialization and reading of results  <br>- Fig_13_10_host_accessor_deadlock.cpp - Bug (hang!) from improper use of host_accessors |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 14 - Common Parallel Patterns](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch14_common_parallel_patterns)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_14_8_one_reduction.cpp - Reduction expressed as an ND-range data-parallel kernel using the reduction library  <br>- Fig_14_11_user_defined_reduction.cpp - Using a user-defined reduction to find the location of the minimum value with an ND-range kernel  <br>- Fig_14_13_map.cpp - Implementing the map pattern in a data-parallel kernel  <br>- Fig_14_14_stencil.cpp - Implementing the stencil pattern in a data-parallel kernel  <br>- Fig_14_15_local_stencil.cpp - Implementing the stencil pattern in an ND-range kernel, using work-group local memory  <br>- Fig_14_18-20_inclusive_scan.cpp - Implementing a naïve reduction expressed as a  data-parallel kernel  <br>- Fig_14_22_local_pack.cpp - Using a sub-group pack operation to build a list of elements needing additional postprocessing  <br>- Fig_14_24_local_unpack.cpp - Using a sub-group unpack operation to improve load balancing for kernels with divergent control flow|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 15 - Programming for GPUs](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch15_gpus)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_15_3_single_task_matrix_multiplication.cpp - A single task matrix multiplication looks a lot like CPU host code  <br>- Fig_15_5_somewhat_parallel_matrix_multiplication.cpp - Somewhat-parallel matrix multiplication  <br>- Fig_15_7_more_parallel_matrix_multiplication.cpp - Even more parallel matrix multiplication  <br>- Fig_15_10_divergent_control_flow.cpp - Kernel with divergent control flow  <br>- Fig_15_12_small_work_group_matrix_multiplication.cpp - Inefficient single-item, somewhat-parallel matrix multiplication  <br>- Fig_15_18_columns_matrix_multiplication.cpp - Computing columns of the result matrix in parallel, not rows|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 16 - Programming for CPUs](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch16_cpus)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_16_6_stream_triad.cpp - DPC++ STREAM Triad parallel_for kernel code  <br>- Fig_16_12_forward_dep.cpp - Using a sub-group to vectorize a loop with a forward dependence  <br>- Fig_16_18_vector_swizzle.cpp - Using vector types and swizzle operations in the single_task kernel|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 17 - Programming for FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch17_fpgas)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_17_9_fpga_selector.cpp - Choosing an FPGA device at runtime using the  <br>- Fig_17_11_fpga_emulator_selector.cpp - Using fpga_emulator_selector for rapid development and debugging  <br>- Fig_17_17_ndrange_func.cpp - Multiple work-item (16 × 16 × 16) invocation of a random number generator  <br>- Fig_17_18_loop_func.cpp - Loop-carried data dependence (state)  <br>- Fig_17_20_loop_carried_deps.cpp - Loop with two loop-carried dependences (i.e., i and a)  <br>- Fig_17_22_loop_carried_state.cpp - Random number generator that depends on previous value generated  <br>- Fig_17_31_inter_kernel_pipe.cpp - Pipe between two kernels: (1) ND-range and (2) single task with a loop  |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 18 - Libraries](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch18_using_libs)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_18_1_builtin.cpp - Using std::log and sycl::log  <br>- Fig_18_7_swap.cpp - Using std::swap in device code  <br>- Fig_18_11_std_fill.cpp - Using std::fill  <br>- Fig_18_13_binary_search.cpp - Using binary_search <br>- Fig_18_15_pstl_usm.cpp - Using Parallel STL with a USM allocator  Errata - code samples for 18-10, 18-12, 18-14, and 19-17 are not in the repository |
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 19 - Memory Model and Atomics](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Ch19_memory_model_and_atomics)|['CPU', 'GPU']|Collection of Code samples for the chapter<br>- Fig_19_3_data_race.cpp - Kernel containing a data race  <br>- Fig_19_6_avoid_data_race_with_barrier.cpp - Avoiding a data race using a barrier   <br>- Fig_19_7_avoid_data_race_with_atomics.cpp - Avoiding a data race using atomic operations  <br>- Fig_19_15_buffer_and_atomic_ref.cpp - Accessing a buffer via an explicitly created atomic_ref  <br>- Fig_19_16_atomic_accessor.cpp - Accessing a buffer via an atomic_ref implicitly created by an atomic accessor  <br>- Fig_19_18_histogram.cpp - Computing a histogram using atomic references in different memory spaces   <br>- Fig_19_19-20_device_latch.cpp - Combining Figure 19-20. Using and building a simple device-wide latch on top of atomic references  Errata - code samples for 18-10, 18-12, 18-14, and 19-17 are not in the repository|
|[Pub: Data Parallel C++:](https://www.apress.com/9781484255735)<br>[Chapter 20 - Epilogue Future Direction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Publications/DPC++/Epilogue_future_direction)|['CPU', 'GPU']|Collection of Code samples for the chapterEpilogue source code examples: Future Direction of DPC++  <br>- Fig_ep_1_mdspan.cpp - Attaching accessor-like indexing to a USM pointer using mdspan  <br>- Fig_ep_2-4_generic_space.cpp - Storing pointers to a specific address space in a class - Figure EP-3. Storing pointers to the generic address space in a class - Figure EP-4. Storing pointers with an optional address space in a class  <br>- Fig_ep_5_extension_mechanism.cpp - Checking for Intel sub-group extension compiler support with #ifdef  <br>- Fig_ep_6_device_constexpr.cpp - Specializing kernel code based on device aspects at kernel compile time  <br>- Fig_ep_7_hierarchical_reduction.cpp - Using hierarchical parallelism for a hierarchical reduction|
|[CMake FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-fpga)|['FPGA']|Project Templates - Linux CMake project for FPGA|
|[CMake GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/cmake-gpu)|['GPU']|Project Templates - Linux CMake project for GPU|
|[Complex Mult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/complex_mult)|['CPU', 'GPU']|This sample computes Complex Number Multiplication|
|[Compute Units](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/compute_units)|['FPGA']|Intel® FPGA tutorial showcasing a design pattern to enable the creation of compute units|
|[Computed Tomography](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/computed_tomography)|['CPU', 'GPU']|Reconstruct an image from simulated CT data with Intel® oneMKL|
|[CRR Binomial Tree](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/crr)|['FPGA']|This sample shows a Binomial Tree Model for Option Pricing using a FPGA-optimized reference design of the Cox-Ross-Rubinstein (CRR) Binomial Tree Model with Greeks for American exercise options|
|[DB](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/db)|['FPGA']|An FPGA reference design that demonstrates high-performance Database Query Acceleration on Intel® FPGAs|
|[Debugger: Array Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/array-transform)|['CPU', 'GPU']|A small Data Parallel C++ (DPC++) example that is used in the "Get Started Guide" of the Application Debugger to exercise major debugger functionality|
|[Discrete Cosine Transform](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SpectralMethods/DiscreteCosineTransform)|['CPU', 'GPU']|An image processing algorithm as seen in the JPEG compression standard|
|[Double Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/double_buffering)|['FPGA']|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and host-processing to improve system performance|
|[DPC Reduce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/dpc_reduce)|['CPU', 'GPU']|This sample models transform Reduce in different ways showing capability of Intel® oneAPI|
|[DPC++ Essentials Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/Jupyter/oneapi-essentials-training)|['CPU', 'GPU']|DPC++ Essentials Tutorials using Jupyter Notebooks|
|[DPC++ OpenCL Interoperability Samples](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/OpenCLInterop)|['CPU', 'GPU']|Samples showing DPC++ and OpenCL Interoperability|
|[DPCPP Blur](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/dpcpp-blur)|['CPU', 'GPU']|Shows how to use Intel® Video Processing Library (VPL) and Data Parallel C++ (DPC++) to convert I420 raw video file in to BGRA and blur each frame|
|[DPCPP Interoperability](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/dpcpp_interoperability)|['CPU', 'GPU']|Intel® oneDNN SYCL extensions API programming for both Intel® CPU and GPU|
|[DSP Control](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/dsp_control)|['FPGA']|An Intel® FPGA tutorial demonstrating the DSP control feature|
|[Dynamic Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/dynamic_profiler)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the Intel® FPGA Dynamic Profiler for Data Parallel C++ (DPC++) to dynamically collect performance data and reveal areas for optimization|
|[Explicit Data Movement](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/explicit_data_movement)|['FPGA']|An Intel® FPGA tutorial demonstrating an alternative coding style, explicit USM, in which all data movement is controlled explicitly by the author|
|[Fast Recompile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fast_recompile)|['FPGA']|An Intel® FPGA tutorial demonstrating how to separate the compilation of host and device code to save development time|
|[Folder Options DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/folder-options-dpct)|['CPU']|Multi-folder project that illustrates migration of a CUDA project that has files located in multiple folders in a directory tree. Uses the `--in-root` and `--out-root` options to tell the Intel® DPC++ Compatibility Tool where to locate source code to be migrated|
|[Fourier Correlation](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/fourier_correlation)|['CPU', 'GPU']|Compute 1D Fourier correlation with Intel® oneMKL|
|[FPGA Compile](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/GettingStarted/fpga_compile)|['FPGA']|Intel® FPGA tutorial introducing how to compile Data Parallel C++ (DPC++) for Intel® FPGA|
|[FPGA Reg](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/fpga_reg)|['FPGA']|An Intel® FPGA advanced tutorial demonstrating how to apply the Data Parallel C++ (DPC++) extension ext::intel::fpga_reg|
|[Gamma Correction](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/gamma-correction)|['CPU', 'GPU']|Gamma Correction - a nonlinear operation used to encode and decode the luminance of each image pixel|
|[Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/getting_started)|['CPU', 'GPU']|Basic Intel® oneDNN programming model for both Intel® CPU and GPU|
|[GZIP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/gzip)|['FPGA']|Reference design demonstrating high-performance GZIP compression on Intel® FPGA|
|[Hello Decode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-decode)|['CPU', 'GPU']|Shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video decode|
|[Hello Encode](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-encode)|['CPU', 'GPU']|Shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform a simple video encode|
|[Hello VPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneVPL/hello-vpp)|['CPU', 'GPU']|Shows how to use the Intel® oneAPI Video Processing Library (VPL) to perform simple video processing|
|[Hello World GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/Hello_World_GPU)|['GPU']|Template 'Hello World' on GPU|
|[Hidden Markov Models](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/GraphTraversal/hidden-markov-models)|['CPU', 'GPU']|Hidden Markov Models using Data Parallel C++|
|[Histogram](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/histogram)|['CPU', 'GPU']|This sample demonstrates Histogram using Dpstd APIs|
|[Host-Device Streaming using USM](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/simple_host_streaming)|['FPGA']|An FPGA tutorial demonstrating how to stream data between the host and device with low latency and high throughput|
|[IBM Device](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/IoTConnectionTools/ibm-device)|['CPU']|This project shows how-to develop a device code using Watson IoT Platform iot-c device client library, connect and interact with Watson IoT Platform Service|
|[Intel Embree Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/RenderingToolkit/GettingStarted/02_embree_gsg)|['CPU']|This introductory hello rendering toolkit sample illustrates how to cast a ray into a scene with Intel Embree|
|[Intel Implicit SPMD Program Compiler (Intel ISPC) Getting Started: 05_ispc_gsg](https://github.com/oneapi-src/oneAPI-samples/tree/master/RenderingToolkit/GettingStarted/05_ispc_gsg)|['CPU']|This introductory rendering toolkit sample demonstrates how to compile basic programs with Intel ISPC and the system C++ compiler. Use this sample to further explore developing accelerated applications with Intel Embree and Intel Open VKL.|
|[Intel Open Image Denoise Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/RenderingToolkit/GettingStarted/04_oidn_gsg)|['CPU']|This introductory 'hello rendering toolkit' sample program demonstrates how to denoise a raytraced image with Intel Open Image Denoise|
|[Intel Open VKL Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/RenderingToolkit/GettingStarted/03_openvkl_gsg)|['CPU']|This introductory hello rendering toolkit sample program demonstrates how to sample into volumes with Intel Open VKL|
|[Intel OSPRay Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/RenderingToolkit/GettingStarted/01_ospray_gsg)|['CPU']|This introductory 'hello rendering toolkit' sample program demonstrates how to render triangle data with the pathtracer from Intel OSPRay|
|[Intel(R) Extension for Scikit-learn: SVC for Adult dataset](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/Intel_Extension_For_SKLearn_Performance_SVC_Adult)|['CPU']|Use Intel(R) Extension for Scikit-learn to accelerate the training and prediction with SVC algorithm on Adult dataset. Compare the performance of SVC algorithm optimized through Intel(R) Extension for Scikit-learn against original Scikit-learn.|
|[Intel® Modin Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelModin_GettingStarted)|['CPU']|This sample illustrates how to use Modin accelerated Pandas functions and notes the performance gain when compared to standard Pandas functions|
|[Intel® Neural Compressor Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/INC-Sample-for-Tensorflow)|['CPU']|This sample illustrates how to run Intel® Neural Compressor to quantize the FP32 model trained by Keras on Tensorflow to INT8 model to speed up the inference.|
|[Intel® Python Daal4py Distributed K-Means](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedKMeans)|['CPU']|This sample code illustrates how to train and predict with a distributed K-Means model with the Intel® Distribution of Python using the Python API package Daal4py powered by Intel® oneDAL|
|[Intel® Python Daal4py Distributed Linear Regression](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_daal4py_DistributedLinearRegression)|['CPU']|This sample code illustrates how to train and predict with a Distributed Linear Regression model with the Intel® Distribution of Python using the Python API package Daal4py powered by Intel® oneDAL|
|[Intel® Python Daal4py Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_daal4py_GettingStarted)|['CPU']|This sample illustrates how to do Batch Linear Regression using the Python API package Daal4py powered by Intel® oneDAL|
|[Intel® Python Scikit-learn Extension Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/Intel_Extension_For_SKLearn_GettingStarted)|['CPU']|This sample illustrates how to do Image classification using SVM classifier from Python API package SKlearnex with the use of Intel® oneAPI Data Analytics Library (oneDAL).|
|[Intel® Python XGBoost Daal4py Prediction](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_daal4pyPrediction)|['CPU']|This sample code illustrates how to analyze the performance benefit of minimal code changes to port pre-trained XGBoost model to daal4py prediction for much faster prediction|
|[Intel® Python XGBoost Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPython_XGBoost_GettingStarted)|['CPU']|The sample illustrates how to setup and train an XGBoost model on datasets for prediction|
|[Intel® Python XGBoost Performance](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelPython_XGBoost_Performance)|['CPU']|This sample code illustrates how to analyze the performance benefit from using Intel training optimizations upstreamed by Intel to latest XGBoost compared to un-optimized XGBoost 0.81 |
|[Intel® PyTorch Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelPyTorch_GettingStarted)|['CPU']|This sample illustrates how to train a PyTorch model and run inference with Intel® oneMKL and Intel® oneDNN|
|[Intel® Tensorflow Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Getting-Started-Samples/IntelTensorFlow_GettingStarted)|['CPU']|This sample illustrates how to train a TensorFlow model and run inference with oneMKL and oneDNN.|
|[Intel® TensorFlow Horovod Multinode Training](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_Horovod_Multinode_Training)|['CPU']|This sample illustrates how to train a TensorFlow model on multiple nodes in a cluster using Horovod|
|[Intel® TensorFlow Model Zoo Inference With FP32 Int8](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8)|['CPU']|This code example illustrates how to run FP32 and Int8 inference on Resnet50 with TensorFlow using Intel® Model Zoo|
|[Intrinsics](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/Intrinsics)|['CPU']|Demonstrates the Intrinsic functions of the Intel® oneAPI C++ Compiler Classic|
|[IO streaming with DPC++ IO pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/io_streaming)|['FPGA']|An FPGA tutorial describing how to stream data to and from DPC++ IO pipes.|
|[ISO2DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso2dfd_dpcpp)|['CPU', 'GPU']|The ISO2DFD sample illustrates Data Parallel C++ (DPC++) Basics using 2D Finite Difference Wave Propagation|
|[ISO3DFD DPCPP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/iso3dfd_dpcpp)|['CPU']|The ISO3DFD Sample illustrates Data Parallel C++ (DPC++) using Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation|
|[ISO3DFD OMP Offload](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/StructuredGrids/iso3dfd_omp_offload)|['GPU']|A Finite Difference Stencil Kernel for solving 3D Acoustic Isotropic Wave Equation using OpenMP* (OMP)|
|[Jacobi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/ApplicationDebugger/jacobi)|['CPU', 'GPU']|A small Data Parallel C++ (DPC++) example which solves a harcoded linear system with Jacobi iteration. The sample includes two versions of the same program: with and without bugs.|
|[Jacobi Iterative](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/jacobi_iterative)|['CPU', 'GPU']|Calculates the number of iterations needed to solve system of linear equations using Jacobi Iterative method|
|[Kernel Args Restrict](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/kernel_args_restrict)|['FPGA']|Explain the kernel_args_restrict attribute and its effect on the performance of Intel® FPGA kernels|
|[Lidar Object Detection using PointPillars](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/End-to-end-Workloads/LidarObjectDetection-PointPillars)|['CPU', 'GPU']|Object detection using a LIDAR point cloud as input. This implementation is based on the paper 'PointPillars: Fast Encoders for Object Detection from Point Clouds'|
|[Loop Coalesce](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_coalesce)|['FPGA']|An Intel® FPGA tutorial demonstrating the loop_coalesce attribute|
|[Loop Fusion](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_fusion)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the loop_fusion attribute|
|[Loop Initiation Interval](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_initiation_interval)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the initiation_interval attribute|
|[Loop IVDEP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_ivdep)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the loop_ivdep attribute|
|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/loop-unroll)|['CPU', 'GPU']|Demonstrates the use of loop unrolling as a simple optimization technique to speed up compute and increase memory access throughput.|
|[Loop Unroll](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/loop_unroll)|['FPGA']|An Intel® FPGA tutorial design demonstrating the loop_unroll attribute|
|[LSU Control](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/lsu_control)|['FPGA']|An Intel® FPGA tutorial demonstrating how to configure the load-store units (LSU) in Data Parallel C++ (DPC++) program using the LSU controls extension|
|[Makefile FPGA](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-fpga)|['FPGA']|Project Templates - Linux Makefile project for FPGA|
|[Makefile GPU](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ProjectTemplates/makefile-gpu)|['GPU']|Project Templates - Linux Makefile project for GPU|
|[Mandelbrot](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/mandelbrot)|['CPU', 'GPU']|The Mandelbrot Set - a fractal example in mathematics|
|[Mandelbrot OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CombinationalLogic/MandelbrotOMP)|['CPU', 'GPU']|Calculates the Mandelbrot Set and outputs a BMP image representation using OpenMP* (OMP)|
|[Matrix Multiply](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/matrix_mul)|['CPU', 'GPU']|This sample Multiplies two large Matrices in parallel using Data Parallel C++ (DPC++) and OpenMP* (OMP)|
|[Matrix Multiply Advisor](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Advisor/matrix_multiply_advisor)|['CPU', 'GPU']|Simple program that shows how to improve the Intel&reg; oneAPI Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|[Matrix Multiply MKL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/matrix_mul_mkl)|['CPU', 'GPU']|Accelerate Matrix Multiplication with Intel® oneMKL|
|[Matrix Multiply VTune™ Profiler](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/VTuneProfiler/matrix_multiply_vtune)|['CPU', 'GPU']|Simple program that shows how to improve the Data Parallel C++ (DPC++) Matrix Multiplication program using Intel&reg; VTune&trade; Profiler and Intel&reg; Advisor|
|[Max Interleaving](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/max_interleaving)|['FPGA']|An Intel® FPGA tutorial demonstrating the usage of the loop max_interleaving attribute|
|[Mem Channels](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/mem_channel)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the mem_channel buffer property and the -Xsno-interleaving flag|
|[Memory Attributes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/memory_attributes)|['FPGA']|An Intel® FPGA tutorial demonstrating the use of on-chip memory attributes to control memory structures in a Data Parallel C++ (DPC++) program|
|[Merge Sort](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/merge_sort)|['FPGA']|A Reference design demonstrating merge sort on an Intel® FPGA|
|[Merge SPMV](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/SparseLinearAlgebra/merge-spmv)|['CPU', 'GPU']|The Sparse Matrix Vector sample provides a parallel implementation of a Merge based Sparse Matrix and Vector Multiplication Algorithm using Data Parallel C++ (DPC++)|
|[MergeSort OMP](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/GraphTraversal/MergesortOMP)|['CPU']|Classic OpenMP* (OMP) Mergesort algorithm|
|[Monte Carlo European Opt](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_european_opt)|['CPU', 'GPU']|Monte Carlo Simulation of European Options pricing with Intel® oneMKL random number generators|
|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/MapReduce/MonteCarloPi)|['CPU', 'GPU']|Monte Carlo procedure for estimating Pi|
|[Monte Carlo Pi](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/monte_carlo_pi)|['CPU', 'GPU']|Estimating Pi with Intel® oneMKL random number generators|
|[MVDR Beamforming](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/mvdr_beamforming)|['FPGA']|A reference design demonstrating a high-performance streaming MVDR beamformer|
|[N-Body](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/N-BodyMethods/Nbody)|['CPU', 'GPU']|An N-Body simulation is a simulation of a dynamical system of particles, usually under the influence of physical forces, such as gravity. This N-Body sample code is implemented using Data Parallel C++ (DPC++) for CPU and GPU|
|[N-Way Buffering](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/n_way_buffering)|['FPGA']|Intel® FPGA tutorial design to demonstrate overlapping kernel execution with buffer transfers and multi-threaded host-processing to improve system performance|
|[Numba DPPY Essentials training](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Jupyter/Numba_DPPY_Essentials_training)|['CPU', 'GPU']|Numba DPPY Essentials Tutorials using Jupyter Notebooks|
|[On-Chip Memory Cache](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/onchip_memory_cache)|['FPGA']|Intel® FPGA tutorial demonstrating the caching of on-chip memory to reduce loop initiation interval|
|[oneCCL Getting Started](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/oneCCL_Getting_Started)|['CPU', 'GPU']|Basic Intel® oneCCL programming model for both Intel® CPU and GPU|
|[OpenMP Offload](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/CompilerInfrastructure/OpenMP_Offload_Features)|['CPU', 'GPU']|Demonstration of the new OpenMP offload features supported by the Intel(r) oneAPI DPC++/C++ Compiler|
|[OpenMP Offload C++ Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/Jupyter/OpenMP-offload-training)|['CPU', 'GPU']|C++ OpenMP Offload Basics using Jupyter Notebooks|
|[OpenMP Offload Fortran Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/Jupyter/OpenMP-offload-training)|['CPU', 'GPU']|Fortran OpenMP Offload Basics using Jupyter Notebooks|
|[OpenMP* Primes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/CombinationalLogic/openmp-primes)|['CPU']|Fortran Tutorial - Using OpenMP* (OMP)|
|[OpenMP* Reduction](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/C++/ParallelPatterns/openmp_reduction)|['CPU', 'GPU']|This sample models OpenMP* (OMP) Reduction in different ways showing capability of Intel® oneAPI|
|[Optimize Inner Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/optimize_inner_loop)|['FPGA']|An Intel® FPGA tutorial design demonstrating how to optimize the throughput of inner loops with low trip counts|
|[Optimize Integral](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/optimize-integral)|['CPU']|Fortran Sample - Simple Compiler Optimizations|
|[Optimize TensorFlow pre-trained model for inference](https://github.com/oneapi-src/oneAPI-samples/tree/master/AI-and-Analytics/Features-and-Functionality/IntelTensorFlow_InferenceOptimization)|['CPU']|This tutorial will guide you how to optimize a pre-trained model for a better inference performance, and also analyze the model pb files before and after the inference optimizations.|
|[Particle Diffusion](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/StructuredGrids/particle-diffusion)|['CPU', 'GPU']|The Particle Diffusion code sample illustrates Data Parallel C++ (DPC++) using a simple (non-optimized) implementation of a Monte Carlo Simulation of the Diffusion of Water Molecules in Tissue|
|[Pipe Array](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/pipe_array)|['FPGA']|An Intel® FPGA tutorial showcasing a design pattern to enables the creation of arrays of pipes|
|[Pipes](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/pipes)|['FPGA']|How to use Pipes to transfer data between kernels on an Intel® FPGA|
|[Prefix Sum](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/ParallelPatterns/PrefixSum)|['CPU', 'GPU']|Compute Prefix Sum using Data Parallel C++ (DPC++)|
|[Printf](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/printf)|['FPGA']|This FPGA tutorial explains how to use the printf() to print in a DPC++ FPGA program|
|[Private Copies](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/private_copies)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the private_copies attribute to trade off the resource use and the throughput of a DPC++ FPGA program|
|[QRD](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/qrd)|['FPGA']|Reference design demonstrating high-performance QR Decomposition (QRD) of real and complex matrices on a Intel® FPGA|
|[QRI](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/ReferenceDesigns/qri)|['FPGA']|Reference design demonstrating high-performance QR-based matrix inversion (QRI) of real and complex matrices on a Intel® FPGA|
|[Random Sampling Without Replacement](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/random_sampling_without_replacement)|['CPU', 'GPU']|Multiple simple random sampling without replacement with Intel® oneMKL random number generators|
|[Read-Only Cache](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/read_only_cache)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the read-only cache feature to boost the throughput of a DPC++ FPGA program|
|[Remove Loop Carried Dependency](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/loop_carried_dependency)|['FPGA']|An Intel® FPGA tutorial design demonstrating performance optimization by removing loop carried dependencies|
|[Rodinia NW DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/rodinia-nw-dpct)|['CPU']|Migrate a CUDA project using the Intel® DPCT intercept-build feature to create a compilation database. The compilation database provides compilation options, settings, macro definitions and include paths that the Intel® DPC++ Compatibility Tool (DPCT) will use during migration of the project|
|[Scheduler Target FMAX](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/scheduler_target_fmax)|['FPGA']|Explain the scheduler_target_fmax_mhz attribute and its effect on the performance of Intel® FPGA kernels|
|[Sepia Filter](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/CombinationalLogic/sepia-filter)|['CPU', 'GPU']|A program that converts an image to Sepia Tone|
|[Shannonization](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/shannonization)|['FPGA']|An Intel® FPGA tutorial design that demonstrates an optimization for removing computation from the critical path and improves Fmax/II|
|[Simple Add](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++/DenseLinearAlgebra/simple-add)|['CPU', 'GPU', 'FPGA']|This simple sample adds two large vectors in parallel and provides a ‘Hello World!’ like sample to ensure your environment is setup correctly using Data Parallel C++ (DPC++)|
|[Simple Model](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/simple_model)|['CPU', 'GPU']|Run a simple CNN on both Intel® CPU and GPU with sample C++ codes|
|[Sparse Conjugate Gradient](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/sparse_conjugate_gradient)|['CPU', 'GPU']|Solve Sparse linear systems with the Conjugate Gradient method using Intel® oneMKL sparse BLAS|
|[Speculated Iterations](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/speculated_iterations)|['FPGA']|An Intel® FPGA tutorial demonstrating the speculated_iterations attribute|
|[Stable Sort By Key](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/stable_sort_by_key)|['CPU', 'GPU']|This sample models Stable Sort By Key during the sorting of 2 sequences (keys and values) only keys are compared but both keys and values are swapped|
|[Stall Enable](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Features/stall_enable)|['FPGA']|An Intel® FPGA tutorial demonstrating the use_stall_enable_clusters attribute|
|[STREAM](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Benchmarks/STREAM)|['CPU', 'GPU']|The STREAM is a program that measures memory transfer rates in MB/s for simple computational kernels coded in C|
|[Student's T-test](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneMKL/student_t_test)|['CPU', 'GPU']|Performing Student's T-test with Intel® oneMKL Vector Statistics functionality|
|[System Profiling](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/Tools/system_profiling)|['FPGA']|An Intel® FPGA tutorial demonstrating how to use the OpenCL* Intercept Layer to improve a design with the double buffering optimization|
|[TBB ASYNC SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-async-sycl)|['CPU', 'GPU']|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Flow Graph asynchronous node and functional node. The Flow Graph asynchronous node uses SYCL to implement calculations on GPU while the functional node does CPU part of calculations. This TBB ASYNC SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[TBB Resumable Tasks SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-resumable-tasks-sycl)|['CPU', 'GPU']|This sample illustrates how computational kernel can be split for execution between CPU and GPU using Intel® oneTBB Resumable Task and parallel_for. The Intel® oneTBB resumable task uses SYCL to implement calculations on GPU while the parallel_for algorithm does CPU part of calculations. This TBB Resumable Tasks SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[TBB Task SYCL](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB/tbb-task-sycl)|['CPU', 'GPU']|This sample illustrates how 2 Intel® oneTBB tasks can execute similar computational kernels with one task executing SYCL code and another one executing the Intel® oneTBB code. This TBB Task SYCL sample code is implemented using C++ and SYCL language for Intel® CPU and GPU|
|[Triangular Loop](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/triangular_loop)|['FPGA']|An Intel® FPGA tutorial demonstrating an advanced optimization technique for triangular loops|
|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL/tutorials)|['CPU', 'GPU']|oneAPI Collective Communications Library (oneCCL) Tutorials|
|[Tutorials](https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDNN/tutorials)|['CPU', 'GPU']|Intel® oneDNN Tutorials|
|[Vector Add DPCT](https://github.com/oneapi-src/oneAPI-samples/tree/master/Tools/Migration/vector-add-dpct)|['CPU']|Simple project to illustrate the basic migration of CUDA code. Use this sample to ensure your environment is configured correctly and to understand the basics of migrating existing CUDA projects to Data Parallel C++ (DPC++)|
|[Vectorize VecMatMult](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/Fortran/DenseLinearAlgebra/vectorize-vecmatmult)|['CPU']|Fortran Tutorial - Using Auto Vectorization|
|[Zero Copy Data Transfer](https://github.com/oneapi-src/oneAPI-samples/tree/master/DirectProgramming/DPC++FPGA/Tutorials/DesignPatterns/zero_copy_data_transfer)|['FPGA']|An Intel® FPGA tutorial demonstrating zero-copy host memory using the SYCL restricted Unified Shared Memory (USM) model|
Total Samples: 167

Report Generated on:  March 08, 2022
