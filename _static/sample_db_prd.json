[{"name":"1D Heat Transfer","description":"The 1D Heat Transfer sample simulates 1D Heat\nTransfer problem using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/1d_HeatTransfer","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Address Sanitizer","description":"Address Sanitizer sample provides examples of\nerror memory detection in SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/address_sanitizer","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Memory Management","cpuInstructionSets":null},{"name":"alignedTypes","description":"This sample demonstrates the access speed gap of\naligned & misaligned types","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_alignedTypes_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"All Pairs Shortest Paths","description":"All Pairs Shortest Paths finds the shortest paths\nbetween pairs of vertices in a graph using a\nparallel blocked algorithm that enables the\napplication to efficiently offload compute...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphAlgorithms\/all-pairs-shortest-paths","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"american_options","description":"American Options Pricing is a model that is based\non the Monte Carlo method and widely used in\nfinancial services industry. The original CUDA*\nsource code is migrated to SYCL for portability...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_american_options_SYCLmigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Atomic","description":"This openMP sample illustrates the read, write,\nupdate & capture clauses for the atomic directive","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/OpenACCToOpenMP\/guided_Atomic_OpenMPMigration","languages":[{"c":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Base: Vector Add","description":"This simple sample adds two large vectors in\nparallel. Provides a \u2018Hello World!\u2019 like sample to\nensure your environment is setup correctly using\nsimple C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/vector-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Batched Linear Solver","description":"Solve batched linear systems using oneMKL and\nOpenMP target offloading","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/batched_linear_solver","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"bilateralFilter","description":"This sample uses OpenMP directives to perform a\nsimple bilateral filter on an image and measures\nperformance","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/OpenACCToOpenMP\/guided_bilateralfilter_OpenMPMigration","languages":[{"c":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Binomial","description":"Binomial European Option Pricing Model Simulation\nusing Intel\u00ae oneMKL Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/binomial","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Bitonic Sort","description":"Bitonic Sort using C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/bitonic-sort","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Black Scholes","description":"Black Scholes formula calculation using Intel\u00ae\noneMKL Vector Math and Random Number Generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/black_scholes","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Block Cholesky Decomposition","description":"Block Cholesky Decomposition using Intel\u00ae oneMKL\nBLAS and LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_cholesky_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Block LU Decomposition","description":"Block LU Decomposition using Intel\u00ae oneMKL BLAS\nand LAPACK","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/block_lu_decomposition","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Coarray Fortran","description":"Demonstrates how to build and run a serial\nimplementation of a Monte Carlo program, and then\nconvert it to run in parallel using Fortran\ncoarrays.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_Coarray","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"Complex Mult","description":"This sample computes Complex Number Multiplication","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/complex_mult","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Computed Tomography","description":"Reconstruct an image from simulated CT data with\nIntel\u00ae oneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/computed_tomography","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"convolutionSeparable","description":"This sample implements a separable convolution\nfilter of a 2D signal with a gaussian kernel.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_convolutionSeparable_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"cuBLAS Migration","description":"This sample shows the execution of cuBLAS function\nmigrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuBLAS_examples_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"CUDA to SYCL Migration","description":"CUDA_To_SYCL_Migration Tutorials using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/cuda-to-sycl-migration-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Tutorial","cpuInstructionSets":null},{"name":"cuRAND Migration","description":"This sample shows the execution of cuRAND function\nmigrated to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_cuRAND_examples_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Debugger: Array Transform","description":"A small SYCL (C++)  example that is used in the\n\"Get Started Guide\" of the Application Debugger to\nexercise major debugger functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/array-transform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Diamond Dependency","description":"Diamond Dependency kernel structure using SYCL-\nGraph","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCL-Graph\/diamond-dependency","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Discrete Cosine Transform","description":"An image processing algorithm as seen in the JPEG\ncompression standard","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SpectralMethods\/DiscreteCosineTransform","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Distributed Jacobian Solver SYCL\/MPI","description":"Distributed implementation of Jacobian solver with\nOpenMP\/SYCL offload and MPI-3 one-sided.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/MPI\/jacobian_solver","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Dot Product","description":"Dot Product operation using SYCL-Graph","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCL-Graph\/dot-product","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"DPC Reduce","description":"This sample models transform Reduce in different\nways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/dpc_reduce","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"dwtHaar1D Sample","description":"This sample computes Discrete Haar wavelet\ndecomposition for 1D signals with a length which\nis a power of 2.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_dwtHaar1D_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Edge Detection in Simple Binary Images","description":"Offload Fortran loops to a GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/EdgeDetection\/simple-binary-images","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"EigenValues Sample","description":"This sample demonstrates a parallel implementation\nof a bisection algorithm for the computation of\nall eigenvalues of a tridiagonal symmetric matrix\nof arbitrary size.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_eigenValues_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Enable Auto-Mixed Precision for Transfer Learning with TensorFlow","description":"This tutorial guides you through the process of\nenabling auto-mixed precision to use low-precision\ndatatypes, like bfloat16, for transfer learning\nwith TensorFlow*","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Enabling_Auto_Mixed_Precision_for_TransferLearning","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"fastWalshTransform","description":"This sample demonstrates the efficient\nimplementation of naturally-ordered Walsh\ntransform","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_fastWalshTransform_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Fine-tuning Text Classification Model with Intel\u00ae Neural Compressor (INC)","description":"This sample demonstrates how to fine-tune text\nmodel for emotion classification task using Intel\u00ae\nNeural Compressor Quantization Aware Training\n(QAT).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/INC_QuantizationAwareTraining_TextClassification","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Fourier Correlation","description":"Compute Fourier correlation with oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/fourier_correlation","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Getting Started","description":"Basic Intel\u00ae oneDNN programming model for both\nIntel\u00ae CPU and GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneDNN\/getting_started","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Getting Started example for JAX CPU","description":"This sample illustrates how to train a JAX model\nand run inference","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/IntelJAX_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Getting Started with Intel\u00ae Neural Compressor for Quantization","description":"This sample is a getting started guide for Intel\u00ae\nNeural Compressor to do INT8 quantization on a\nHuggingface BERT model. This allows us to achieve\nperformance boosts on Intel hardware.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Quantization-Sample-for-PyTorch","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Guided iso3dfd GPU optimization","description":"Step-by-step GPU optimization guide with Intel\nAdvisor and ISO3DFD sample","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/C++-to-sycl-migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Guided iso3dfd GPU optimization","description":"Step-by-step GPU optimization guide with Intel\nAdvisor and ISO3DFD sample","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/C++-to-sycl-migration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Guided Matrix Multiplication Bad Buffers","description":"The Guided Matrix Multiplication Bad Buffers\nsample demonstrates how to use the Intel\u00ae oneAPI\nBase Toolkit (Base Kit) and several tools found in\nit to triage incorrect use of the SYCL language.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_BadBuffers","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"Guided Matrix Multiplication Illegal SLM Size","description":"The Guided Matrix Multiplication Illegal SLM Size\nsample demonstrates a guided approach to debugging\nincorrect usage when reserving more memory for a\nwork-group than there is space, also called...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/guided_matrix_mult_SLMSize","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"guided_bandwidthTest_SYCLMigration","description":"This sample shows the demonstrates how to measure\nthe memcopy bandwidth of the GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_bandwidthTest_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_concurrentKernels_SYCLMigration","description":"This sample shows the execution of Multiple\nKernels on the device at the same time.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_concurrentKernels_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_cudaOpenMP_SYCLMigration","description":"This sample demonstrates to use OpenMP API to\nwrite an application for multiple GPUs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_cudaOpenMP_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_histogram_SYCLMigration","description":"This sample implements 64-bin histogram\ncalculation of arbitrary-sized 8-bit data array.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_histogram_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_inlinePtx_SYCLMigration","description":"This sample shows the demonstrates the use of SYCL\nqueues for PTX assembly on GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_inlinePtx_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_montecarloMultiGPU_SYCLMigration","description":"Evaluates fair call price for a given set of\nEuropean Options using the MonteCarlo approach","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_monteCarloMultiGPU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"guided_oceanFFT_SYCLMigration","description":"This sample shows the demonstrates the use of SYCL\nqueues for Ocean height field on GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_oceanFFT_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_radixSortThrust_SYCLMigration","description":"Radix Sort Thrust Migrated demonstrates a fast and\nefficient parallel radix sort that uses the SYCL\nversion of the THRUST library","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_radixSortThrust_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"guided_scalarProd_SYCLMigration","description":"This sample calculates scalar products of a given\nset of input vector pairs on CPU and GPU devices.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_scalarProd_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_shfl_scan_SYCLMigration","description":"This sample demonstrates the migration of CUDA\nshuffle intrinsic APIs to SYCL group algorithm to\nperform a scan operation.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_shflScan_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"guided_simpleAtomicIntrinsics_SYCLMigration","description":"This sample demonstrates the use of various SYCL\narithmetic Atomic Intrinsic functions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_simpleAtomicIntrinsics_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Hidden Markov Models","description":"Hidden Markov Models using Data Parallel C++","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/hidden-markov-models","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"HSOpticalFlow","description":"Variational optical flow estimation example. Uses\ntextures for image operations. Shows how simple\nPDE solver can be accelerated with SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_hsOpticalFlow_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Intel PyTorch GPU Inference Optimization with AMP","description":"This sample illustrates how to use AMP BFLOAT16 in\nPyTorch on Intel dGPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_GPU_InferenceOptimization_with_AMP","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":["ats-m","dg2","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Intel\u00ae Extension for PyTorch* Training Optimizations for Bfloat16","description":"This sample illustrates how to train a PyTorch\nmodel using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelPyTorch_TrainingOptimizations_AMX_BF16","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"]},{"name":"Intel\u00ae Extension for Scikit-learn* Getting started","description":"This sample illustrates how to do Image\nclassification using SVM classifier from Python\nAPI package SKlearnex with the use of Intel\u00ae\noneAPI Data Analytics Library (oneDAL).","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/Intel_Extension_For_SKLearn_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Intel\u00ae Extension for TensorFlow* BF16 Inference","description":"This sample illustrates how to inference a\nTensorFlow model using Advanced Matrix Extensions\nBfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Inference","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"]},{"name":"Intel\u00ae Neural Compressor Accelerate Inference with Intel\u00ae Optimization for TensorFlow*","description":"This sample illustrates how to run Intel\u00ae Neural\nCompressor to quantize the FP32 model trained by\nKeras on Tensorflow to INT8 model to speed up the\ninference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/INC-Sample-for-Tensorflow","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Intel\u00ae Optimization for TensorFlow* Getting Started","description":"This sample illustrates how to train a TensorFlow\nmodel and run inference with oneMKL and oneDNN.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Getting-Started-Samples\/TensorFlow_GettingStarted","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Intel\u00ae Optimization for TensorFlow* pre-trained model for inference","description":"This tutorial will guide you how to optimize a\npre-trained model for a better inference\nperformance, and also analyze the model pb files\nbefore and after the inference optimizations.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_InferenceOptimization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Intrinsics","description":"Demonstrates the Intrinsic functions of the Intel\u00ae\noneAPI C++ Compiler Classic","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/Intrinsics","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Introduction to Machine Learning","description":"The Jupyter Notebooks in these samples are\nintended to give professors and students an\naccessible but challenging introduction to machine\nlearning. It enumerates and describes many...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Introduction_to_Machine_Learning","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"ISO2DFD DPCPP","description":"The ISO2DFD sample illustrates SYCL Basics using\n2D Finite Difference Wave Propagation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso2dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"ISO3DFD","description":"The ISO3DFD Sample illustrates SYCL using Finite\nDifference Stencil Kernel for solving 3D Acoustic\nIsotropic Wave Equation","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/iso3dfd_dpcpp","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"ISO3DFD OMP Offload","description":"A Finite Difference Stencil Kernel for solving 3D\nAcoustic Isotropic Wave Equation using OpenMP*\n(OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/StructuredGrids\/iso3dfd_omp_offload","languages":[{"cpp":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Jacobi","description":"A small SYCL (C++) example which solves a harcoded\nlinear system with Jacobi iteration. The sample\nincludes two versions of the same program: with\nand without bugs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/ApplicationDebugger\/jacobi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Jacobi Cuda Graphs","description":"Migration of JacobiCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\ninplace of CUDA Graph API's and optimization of\nthe migrated code","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_jacobiCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Jacobi Iterative Solver","description":"Jacobi Iterative Solver provides step by step\ninstructions for CPU, GPU and multiple GPU offload","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/guided_jacobi_iterative_gpu_optimization","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"JobRecommendationSystem: End-to-End Deep Learning Workload","description":"This sample illustrates the use of Intel\u00ae\nExtension for TensorFlow* to build and run an end-\nto-end AI workload on the example of the job\nrecommendation system","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/JobRecommendationSystem","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Reference Designs and End to End","cpuInstructionSets":null},{"name":"Leveraging Intel Extension for TensorFlow with LSTM for Text Generation","description":"This sample demonstrates how to train your model\nwith LSTM (Long short-term memory) faster by using\nIntel Extension for TensorFlow's LSTM training\nlayer on Intel platform","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_TextGeneration_with_LSTM","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Lidar Object Detection using PointPillars","description":"Object detection using a LIDAR point cloud as\ninput. This implementation is based on the paper\n'PointPillars: Fast Encoders for Object Detection\nfrom Point Clouds'","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/End-to-end-Workloads\/LidarObjectDetection-PointPillars","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Reference Designs and End to End","cpuInstructionSets":null},{"name":"Loop Unroll","description":"Demonstrates the use of loop unrolling as a simple\noptimization technique to speed up compute and\nincrease memory access throughput.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/loop-unroll","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Mandelbrot","description":"The Mandelbrot Set - a fractal\u00a0example\nin\u00a0mathematics","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/mandelbrot","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Mandelbrot OMP","description":"Calculates the Mandelbrot Set and outputs a BMP\nimage representation using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CombinationalLogic\/MandelbrotOMP","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Matrix Multiplication cuBLAS Migrated","description":"This sample shows the migration of a more complex\nmatrix multiplication sample from cuBLAS to SYCL.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_matrix_mul_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Matrix Multiply","description":"This sample Multiplies two large Matrices in\nparallel using SYCL and OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/guided_matmul_opt_report","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Matrix Multiply","description":"Demonstrates how compiler auto-vectorization can\nimprove the performance of a program. The\noptimization report option is used to identify\npotential points of performance improvement.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/guided_matmul_opt_report","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"Matrix Multiply Advisor","description":"Simple program that shows how to improve the\nIntel&reg; oneAPI Data Parallel C++ (DPC++) Matrix\nMultiplication program using Intel&reg;\nVTune&trade; Profiler and Intel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Advisor\/matrix_multiply_advisor","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Matrix Multiply Fortran","description":"Demonstrates how to use OpenMP* directives with\nFortran to offload computations to an Intel GPU.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/guided_matrix_mul_OpenMP","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Tutorial","cpuInstructionSets":null},{"name":"Matrix Multiply MKL","description":"Accelerate Matrix Multiplication with Intel\u00ae\noneMKL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/matrix_mul_mkl","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Matrix Multiply VTune\u2122 Profiler","description":"Simple program that shows how to improve the Data\nParallel C++ (DPC++) Matrix Multiplication program\nusing Intel&reg; VTune&trade; Profiler and\nIntel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_vtune","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Matrix Multiply VTune\u2122 Profiler - C","description":"Simple program that shows how to improve the C\nlanguage (CPU only) Matrix Multiplication program\nusing Intel&reg; VTune&trade; Profiler and\nIntel&reg; Advisor","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/VTuneProfiler\/matrix_multiply_c","languages":[{"c":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Merge SPMV","description":"The Sparse Matrix Vector sample provides a\nparallel implementation of a Merge based Sparse\nMatrix and Vector Multiplication Algorithm using\nSYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SparseLinearAlgebra\/merge-spmv","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"MergeSort OMP","description":"Classic OpenMP* (OMP) Mergesort algorithm","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/GraphTraversal\/MergesortOMP","languages":[{"cpp":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Model Zoo for Intel\u00ae Architecture Inference With FP32 Int8","description":"This code example illustrates how to run FP32 and\nInt8 inference on Resnet50 with TensorFlow using\nIntel\u00ae Model Zoo","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_ModelZoo_Inference_with_FP32_Int8","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Monte Carlo European Opt","description":"Monte Carlo Simulation of European Options pricing\nwith Intel\u00ae oneMKL random number generators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/monte_carlo_european_opt","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Monte Carlo Pi","description":"Monte Carlo procedure for estimating Pi","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/MonteCarloPi","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Monte Carlo Pi","description":"Estimating Pi with Intel\u00ae oneMKL random number\ngenerators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/MapReduce\/MonteCarloPi","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"MonteCarloMultiGPU","description":"This sample uses OpenMP directives to implement a\nMonte Carlo simulation to estimate the price of a\nEuropean call option and its confidence interval.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/OpenACCToOpenMP\/guided_MonteCarloMultiGPU_OpenMPMigration","languages":[{"c":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"MPI Communications Using GPU Buffers","description":"Sample to demonstrate basic MPI communications\nusing GPU buffers.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/MPI\/mpi_send_gpu","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"N-Body","description":"An N-Body simulation is a simulation of a\ndynamical system of particles, usually under the\ninfluence of physical forces, such as gravity.\nThis N-Body sample code is implemented using...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/N-BodyMethods\/Nbody","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Numba Data Parallel Python* Essentials Training","description":"Numba Data Parallel Python* Essentials Tutorials\nusing Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Numba_dpex_Essentials_training","languages":[{"python":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"Odd Even Merge Sort","description":"This is the preferred algorithm of choice for\nsorting batches of short-sized to mid-sized (key,\nvalue) array pairs.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_oddEvenMergeSort_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"OpenMP Offload","description":"Demonstration of the new OpenMP offload features\nsupported by the Intel(r) oneAPI DPC++\/C++\nCompiler","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/CompilerInfrastructure\/OpenMP_Offload_Features","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"OpenMP Offload C++ Tutorials","description":"C++ OpenMP Offload Basics using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/Jupyter\/OpenMP-offload-training","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"OpenMP Offload Fortran Tutorials","description":"Fortran OpenMP Offload Basics using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/Jupyter\/OpenMP-offload-training","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"OpenMP* Primes","description":"Fortran Tutorial - Using OpenMP* (OMP)","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/CombinationalLogic\/openmp-primes","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"OpenMP* Reduction","description":"This sample models OpenMP* (OMP) Reduction in\ndifferent ways showing capability of Intel\u00ae oneAPI","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++\/ParallelPatterns\/openmp_reduction","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Optimize Integral","description":"Fortran Sample - Simple Compiler Optimizations","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/optimize-integral","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Particle Diffusion","description":"The Particle Diffusion code sample illustrates\nSYCL using a simple (non-optimized) implementation\nof a Monte Carlo Simulation of the Diffusion of\nWater Molecules in Tissue","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/StructuredGrids\/particle-diffusion","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Performance_Analysis_using_model_zoo_for_Intel_Architecture","description":"This sample contains one Jupyter notebook from\nthis GitHub Repo and four Jupyter Notebooks from\nthe Model Zoo for Intel\u00ae Architecture to help\nusers analyze the performance difference among...","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_PerformanceAnalysis","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Performance Analysis","cpuInstructionSets":null},{"name":"Predictive Modeling with XGBoost* and the AI Tools","description":"Predictive Modeling using Decision Trees, Bagging,\nand XGBoost using AI Tools and Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Training\/Predictive_Modeling_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Prefix Sum","description":"Compute Prefix Sum using SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/ParallelPatterns\/PrefixSum","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Quantize Transformer Models using Intel\u00ae Extension for Transformers* (ITREX)","description":"Quantizing Transformer models in a step-by-step\nmanner to enable memory efficient LLM inference.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTransformers_Quantization","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"quasirandomGenerator","description":"Implements Niederreiter Quasirandom Sequence\nGenerator and Inverse Cumulative Normal\nDistribution functions for the generation of\nStandard Normal Distributions.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_quasirandomGenerator_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Radix Sort Thrust Migrated","description":"Radix Sort Thrust Migrated demonstrates a fast and\nefficient parallel radix sort that uses the SYCL\nversion of the THRUST library","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/GraphTraversal\/radix_sort_thrust_migrated","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Code Optimization","cpuInstructionSets":null},{"name":"Random Sampling Without Replacement","description":"Multiple simple random sampling without\nreplacement with Intel\u00ae oneMKL random number\ngenerators","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/random_sampling_without_replacement","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Run distributed deep learning workloads with Intel\u00ae Optimization for Horovod","description":"This sample demonstrates how to run multi-card\ninference and training on Intel GPUs using Intel\nOptimization for Horovod and TensorFlow","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Horovod_Distributed_Deep_Learning","languages":[{"python":{}}],"targetDevice":["GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"segmentationTreeThrust","description":"Demonstrates an approach to the image segmentation\ntrees construction.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_segmentationTree_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Sepia Filter","description":"A program that converts an image to Sepia Tone","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/CombinationalLogic\/sepia-filter","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Simple Add","description":"This simple sample adds two large vectors in\nparallel and provides a \u2018Hello World!\u2019 like sample\nto ensure your environment is setup correctly\nusing C++ with SYCL","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/DenseLinearAlgebra\/simple-add","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"Simple Cuda Graphs Sample","description":"Migration of simpleCudaGraphs from CUDA to SYCL,\ndemonstrates usage of Taskflow programming model\nand SYCL Graph extension in place of CUDA Graph\nAPIs","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_simpleCudaGraphs_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concept and Functionality","cpuInstructionSets":null},{"name":"simpleCUBLAS_LU","description":"This sample implements LU decomposition factors a\nmatrix as the product of an upper triangular\nmatrix and lower triangular matrix.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/guided_simpleCUBLAS_LU_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Sobel Edge Detection","description":"Offload Fortran loops to a GPU","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/EdgeDetection\/sobel-edge-detection","languages":[{"fortran":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Sparse Conjugate Gradient","description":"Solve Sparse linear systems with the Conjugate\nGradient method using Intel\u00ae oneMKL Sparse BLAS","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/sparse_conjugate_gradient","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"STREAM","description":"The STREAM is a program that measures memory\ntransfer rates in MB\/s for simple computational\nkernels coded in C","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Tools\/Benchmarks\/STREAM","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":["gen9","pvc"],"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Student's T-test","description":"Performing Student's T-test with Intel\u00ae oneMKL\nVector Statistics functionality","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/Libraries\/oneMKL\/student_t_test","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":null},{"name":"SYCL Essentials Tutorials","description":"SYCL Essentials Tutorials using Jupyter Notebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/oneapi-essentials-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"SYCL OpenCL Interoperability Samples","description":"Samples showing SYCL and OpenCL Interoperability","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/OpenCLInterop","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"SYCL Performance Portability","description":"SYCL Performance Portability using Jupyter\nNotebooks","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/Jupyter\/sycl-performance-portability-training","languages":[{"cpp":{"properties":{"projectOptions":[{"projectType":"makefile"}]}}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Tutorial","cpuInstructionSets":null},{"name":"TensorFlow Fine-tuning and Inference for LLMs with Bfloat16","description":"This sample illustrates how to fine-tune and do\ninference of a TensorFlow LLM model using Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_for_LLMs","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"]},{"name":"TensorFlow Training Optimizations with Advanced Matrix Extensions Bfloat16","description":"This sample illustrates how to train a TensorFlow\nmodel using Advanced Matrix Extensions Bfloat16","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_AMX_BF16_Training","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Code Optimization","cpuInstructionSets":["AVX512","AMX"]},{"name":"TensorFlow Transformer with Advanced Matrix Extensions bfloat16 Mixed Precision Learning","description":"This sample code demonstrates optimizing a\nTensorFlow model with Intel\u00ae Advanced Matrix\nExtensions (Intel\u00ae AMX) using bfloat16 (Brain\nFloating Point) on Sapphire Rapids","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/AI-and-Analytics\/Features-and-Functionality\/IntelTensorFlow_Transformer_AMX_bfloat16_MixedPrecision","languages":[{"python":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Getting Started","cpuInstructionSets":["AVX512","AMX"]},{"name":"threadFenceReduction","description":"Implements a reduction operation on an array of\nvalues using the sycl::atomic_fence function to\nproduce a single value in a single kernel.","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/C++SYCL\/SYCLMigration\/guided_threadFenceReduction_SYCLMigration","languages":[{"cpp":{}}],"targetDevice":["CPU","GPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null},{"name":"Vectorize VecMatMult","description":"Fortran Tutorial - Using Auto Vectorization","url":"https:\/\/github.com\/oneapi-src\/oneAPI-samples\/tree\/master\/DirectProgramming\/Fortran\/DenseLinearAlgebra\/vectorize-vecmatmult","languages":[{"fortran":{}}],"targetDevice":["CPU"],"gpuRequired":null,"expertise":"Concepts and Functionality","cpuInstructionSets":null}]