/*
  Title:          Simple DMA Test


  Important:

  More details about the design are captured in the kernel file and the top
  level readme.txt file.  At a minimum give readme.txt a look since I document
  how to use the example and any limitations that you may need to be aware of.


  Tool Versions:

  The design was created with the following design environment:

  1) Quartus 23.1 (Design includes Nios V/g which was released in 23.1)
  2) Questasim Intel edition (Installed with Quartus)
  3) oneAPI 2023.1.0
  4) Linux development host (Ubuntu 22.04 was used, this design *should* work on
     windows but build_software.sh does not)


  Description:


  This design leverages a simple DMA oneAPI kernel that has had its RTL
  generated and integrated into the Nios V test system that will be used to
  control the accelerator. The DMA kernel has been configured to read from
  memory in memory location 0 (BL0) while writes to memory in memory location 1
  (BL1). To see where this is important view the code that handles the second
  write to the source and destination pointer registers.

  The CPU is configured to have a single peripheral space located at 0x0010_0000
  and it is 1MB in size.  So if you want to connect a different kernel/IP make
  sure to place it between data master address 0x0010_0000-0x001F_FFFF.  If you
  run out of room (doubtful but possible) go into the Nios V parameterization
  GUI and add a second peripheral region. I think the way it works with Nios V
  is if you deference a pointer to either peripheral region it automatically
  bypasses the data cache.  I wanted to be backwards compatible with Nios II so
  I reuse the old handy dandy IOWR_32DIRECT and IORD_32DIRECT macros to access
  the peripheral region instead (see comments about the 12-bit offset
  limitation).

  Nios V is a 32-bit processor but oneAPIs types like pointers and 64-bit types
  need to be written in two 32-bit parts.  Luckily bypassing the Nios V data
  cache (D$) is as simple as dereferencing a pointer in the peripheral space
  (0x0010_0000-0x001F_FFFF).  This code should be backwards compatible with Nios
  II since I leveraged the IOWR_32DIRECT and IORD_32DIRECT macros.  According to
  io.h there is a upper limitation of 12-bits of the offset field, so this code
  instead does the safe thing and adds the offset to the base (first argument of
  macro) and hardcodes the offset field to 0 (second argument of macro).


  Author:         JCJB Date:           5/23/2023


  Version:        0.1

  Version History:

    0.1:  Initial version of the design that has Nios V controlling a simple
  oneAPI DMA kernel that copies data from source to destination four bytes at a
  time.

*/

#include <stdio.h>
#include <stdlib.h>

// This comes from the BSP and contains Nios V data cache flushing APIs
#include <sys/alt_cache.h>

// This comes from the BSP that was generated by software_build.h, it includes
// the macros used to access the control/status registers of peripherals
#include "io.h"

// This comes from the BSP that was generated by software_build.h, it contains
// information like address map, IRQ mapping, etc...
#include "system.h"

// including the kernel register map directly from the kernel build directory
#include "../../../kernels/simple_dma/build/simple_dma.report.prj/register_map_offsets.hpp"

/*
   In bytes, must be a multiple of 4.  Keep it a small number to shorten the
   simulation time and do not exceed the 1MB memory size (remember this code is
   in there too). Once the DMA gets going this buffer will fly by fast so
   setting it too high mostly affects the memory initialization and the
   correctness check at the end once the DMA gets going this buffer will fly by
   fast so setting it too high mostly affects the memory initialization and the
   correctness check at the end.
*/
#define BUFFER_LENGTH 1024

// Error numbers
#define TEST_PASS 0
#define TEST_FAIL 1

/// NIOS V limits the offset of the `IOWR32...` macros to 12 bits, so explicitly
/// add the offset to the base, since the base address parameter of the macro
/// does not have the limitation.
#define REG_ARG_SOURCE_BASE \
  (SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_SOURCE_REG)
#define REG_ARG_DEST_BASE        \
  (SIMPLE_DMA_ACCELERATOR_BASE + \
   ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_DESTINATION_REG)
#define REG_ARG_LENGTH_BASE \
  (SIMPLE_DMA_ACCELERATOR_BASE ZTS9SIMPLEDMA_REGISTER_MAP_ARG_ARG_LENGTH_REG)
#define REG_START_BASE \
  (SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_START_REG)
#define REG_STATUS \
  (SIMPLE_DMA_ACCELERATOR_BASE + ZTS9SIMPLEDMA_REGISTER_MAP_STATUS_REG)

/// @brief configure and start the Simple DMA Accelerator IP
///
/// @details `configure_and_start_dma` will accept the source, destination, and
/// transfer length and write them into the kernel CSRs leveraging the old Nios
/// IORW/IORD_32DIRECT macros, since those also work for Nios II.
///
/// @note Since the kernel is located in the I/O space of the Nios V processor,
/// you may choose to simply dereference a pointer to bypass the data cache but
/// that doesn't port to Nios II directly so that has been avoided here
///
/// @param[in] source Pointer to source memory to copy from
///
/// @param[in] destination Pointer to which to copy data
///
/// @param[in] length Number of bytes of data to copy
void configure_and_start_dma(unsigned int* source, unsigned int* destination,
                             unsigned int length) {
  // (note:  Nios V/g is 32-bit so we have to write the source pointer 32 bits
  // at a time. The source pointer needs to be cast to unsigned int since the
  // Nios macros are not expecting a pointer.

  // DMA source
  IOWR_32DIRECT(REG_ARG_SOURCE_BASE, 0, (unsigned int)source);
  // padding upper 32 bits to all zeros
  IOWR_32DIRECT(REG_ARG_SOURCE_BASE + 4, 0, 0);

  // DMA destination
  IOWR_32DIRECT(REG_ARG_DEST_BASE, 0, (unsigned int)destination);
  // padding upper 32 bits to all zeros
  IOWR_32DIRECT(REG_ARG_DEST_BASE + 4, 0, 0);

  // DMA length
  IOWR_32DIRECT(REG_ARG_LENGTH_BASE, 0, BUFFER_LENGTH);

  // DMA start
  IOWR_32DIRECT(REG_START_BASE, 0, 1);

  // The DMA kernel should immediately start at this point
}

/// @brief Exercise the DMA kernel.
///
/// The test has the following phases: \n
///
/// 1. populate a source buffer with an incrementing pattern of 'BUFFER_LENGTH'
/// bytes \n
///
/// 2. clear out the destination buffer \n
///
/// 3. instruct the DMA kernel to perform the source --> destination transfer \n
///
/// 4. check that the destination contents match the source
///
/// @return 0 if the test passes.
int test_simple_dma() {
  // allocating source and destination buffers at compile time so that if too
  // large a value is set for BUFFER_LENGTH then we'll find out early at compile
  // time
  unsigned int source[BUFFER_LENGTH / 4];
  unsigned int destination[BUFFER_LENGTH / 4];
  int i;

  // initialize the source buffer with an incrementing pattern and clear out the
  // destination before the accelerator clobbers it
  for (i = 0; i < (BUFFER_LENGTH / 4); i++) {
    source[i] = i;
    destination[i] = 0;
  }

  // main memory (code_data_ram) is *not* in a peripheral region so all those
  // writes to the source and destination need to be flushed from the data cache
  // to avoid cache coherency issues when the accelerator attempts to access
  // memory

  // make sure all that source data that was set gets flushed out to main memory
  alt_dcache_flush(source, BUFFER_LENGTH);

  // make sure all that destination data that was zeroed out gets flushed out to
  // main memory
  alt_dcache_flush(destination, BUFFER_LENGTH);

  //  Configure and start the DMA kernel
  configure_and_start_dma(source, destination, BUFFER_LENGTH);

  // spin waiting for the accelerator to complete (kernel will fire off
  // interrupt as well but there is no register as of 2023.1.0 to clear it)
  while ((IORD_32DIRECT(REG_STATUS, 0) & KERNEL_REGISTER_MAP_DONE_MASK) !=
         KERNEL_REGISTER_MAP_DONE_MASK) {
  }

  // Now that the accelerator is done, test the destination buffer for
  // correctness. Since the destination buffer was already flushed from the data
  // cache, software can safely read the destination without additional data
  // flushes. Since the source was previously flushed as well, it will get
  // fetched from main memory and warm up the D$ just like the destination
  // buffer in the correctness loop.

  // test the results at the destination buffer, if a failure is detected set
  // pass to 0 and stop testing
  for (i = 0; i < (BUFFER_LENGTH / 4); i++) {
    if (source[i] != destination[i]) {
      printf(
          "Test Fail:  Source address = 0x%x, Destination address = 0x%x, byte "
          "offset 0x%x.  Read value 0x%x instead of expected value 0x%x.\n",
          (unsigned int)source, (unsigned int)destination, (i * 4),
          destination[i], source[i]);
      return TEST_FAIL;
    }
  }

  // If we reach this point then all the data must have passed so we can issue a
  // blanket statement that the entire test passed
  printf("Test Pass:  All the data at the destination matches the source.\n");

  return TEST_PASS;
}

/// @brief main function
///
/// @return 0 on a test pass and non-zero on failures, see error numbers near
/// top of this file.
int main() {
  int return_val;

  printf("Test design for the simple DMA kernel\n\n");
  printf(
      "Test will initialize %d incrementing four byte unsigned integers, have "
      "the accelerator DMA copy the data to a destination and then check the "
      "destination for correctness.\n",
      (BUFFER_LENGTH / 4));

  return_val = test_simple_dma();
  printf("Software will now exit.\n");
  return return_val;
}
