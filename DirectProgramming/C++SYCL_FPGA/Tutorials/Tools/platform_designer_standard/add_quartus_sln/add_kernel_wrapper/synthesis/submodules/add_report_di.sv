// (c) 1992-2024 Intel Corporation.                                             
// Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack        
// words and logos are trademarks of Intel Corporation or its                   
// subsidiaries in the U.S. and/or other countries. Other marks and             
// brands may be claimed as the property of others.                             
// See Trademarks on intel.com for full list of Intel trademarks or the         
// Trademarks & Brands Names Database (if Intel)                                
// or See www.Intel.com/legal (if Altera)                                       
// Your use of Intel Corporation's design tools, logic functions and            
// other software and tools, and its AMPP partner logic functions, and          
// any output files any of the foregoing (including device programming          
// or simulation files), and any associated documentation or information        
// are expressly subject to the terms and conditions of the Altera              
// Program License Subscription Agreement, Intel MegaCore Function              
// License Agreement, or other applicable license agreement, including,         
// without limitation, that your use is for the sole purpose of                 
// programming logic devices manufactured by Intel and sold by Intel or         
// its authorized distributors.                                                 
// Please refer to the applicable agreement for further details.                
// Generated by Intel(R) FPGA SDK for OpenCL(TM), Version 2024.2.1 Build 8907061a4a7bb8b03783e9f52adc9762aaf4d91d Pro Edition, Copyright (c) 2024 Intel Corporation

/////////////////////////////////////////////////////////////////
// MODULE add_report_di
/////////////////////////////////////////////////////////////////
module add_report_di
(
   input logic clock,
   input logic resetn,
   output logic [63:0] device_exception_bus,
   output logic kernel_irqs,
   // AVS csr_ring_root_avs
   input logic csr_ring_root_avs_enable,
   input logic csr_ring_root_avs_read,
   input logic csr_ring_root_avs_write,
   input logic [4:0] csr_ring_root_avs_address,
   input logic [63:0] csr_ring_root_avs_writedata,
   input logic [7:0] csr_ring_root_avs_byteenable,
   output logic csr_ring_root_avs_waitrequest,
   output logic [63:0] csr_ring_root_avs_readdata,
   output logic csr_ring_root_avs_readdatavalid
);
   logic cra_ring_node_avm_wire_0_enable;
   logic cra_ring_node_avm_wire_0_read;
   logic cra_ring_node_avm_wire_0_write;
   logic [4:0] cra_ring_node_avm_wire_0_address;
   logic [63:0] cra_ring_node_avm_wire_0_writedata;
   logic [7:0] cra_ring_node_avm_wire_0_byteenable;
   logic [63:0] cra_ring_node_avm_wire_0_readdata;
   logic cra_ring_node_avm_wire_0_readdatavalid;
   logic cra_ring_node_avm_wire_0_burstcount;

   // INST IDAdder_std_ic_inst of IDAdder_std_ic_partition_wrapper
   IDAdder_std_ic_partition_wrapper IDAdder_std_ic_inst
   (
      .clock(clock),
      .resetn(resetn),
      .cra_irq_IDAdder(kernel_irqs),
      // AVS avs_IDAdder_cra
      .avs_IDAdder_cra_enable(cra_ring_node_avm_wire_0_enable),
      .avs_IDAdder_cra_read(cra_ring_node_avm_wire_0_read),
      .avs_IDAdder_cra_write(cra_ring_node_avm_wire_0_write),
      .avs_IDAdder_cra_address(cra_ring_node_avm_wire_0_address),
      .avs_IDAdder_cra_writedata(cra_ring_node_avm_wire_0_writedata),
      .avs_IDAdder_cra_byteenable(cra_ring_node_avm_wire_0_byteenable),
      .avs_IDAdder_cra_readdata(cra_ring_node_avm_wire_0_readdata),
      .avs_IDAdder_cra_readdatavalid(cra_ring_node_avm_wire_0_readdatavalid)
   );

   // INST cra_ring_wrapper_inst of cra_ring_wrapper
   cra_ring_wrapper cra_ring_wrapper_inst
   (
      .clock(clock),
      .resetn(resetn),
      // AVS csr_ring_root_avs
      .csr_ring_root_avs_enable(csr_ring_root_avs_enable),
      .csr_ring_root_avs_read(csr_ring_root_avs_read),
      .csr_ring_root_avs_write(csr_ring_root_avs_write),
      .csr_ring_root_avs_address(csr_ring_root_avs_address),
      .csr_ring_root_avs_writedata(csr_ring_root_avs_writedata),
      .csr_ring_root_avs_byteenable(csr_ring_root_avs_byteenable),
      .csr_ring_root_avs_waitrequest(csr_ring_root_avs_waitrequest),
      .csr_ring_root_avs_readdata(csr_ring_root_avs_readdata),
      .csr_ring_root_avs_readdatavalid(csr_ring_root_avs_readdatavalid),
      // AVM cra_ring_avm_0
      .cra_ring_avm_0_enable(cra_ring_node_avm_wire_0_enable),
      .cra_ring_avm_0_read(cra_ring_node_avm_wire_0_read),
      .cra_ring_avm_0_write(cra_ring_node_avm_wire_0_write),
      .cra_ring_avm_0_address(cra_ring_node_avm_wire_0_address),
      .cra_ring_avm_0_writedata(cra_ring_node_avm_wire_0_writedata),
      .cra_ring_avm_0_byteenable(cra_ring_node_avm_wire_0_byteenable),
      .cra_ring_avm_0_readdata(cra_ring_node_avm_wire_0_readdata),
      .cra_ring_avm_0_readdatavalid(cra_ring_node_avm_wire_0_readdatavalid),
      .cra_ring_avm_0_burstcount(cra_ring_node_avm_wire_0_burstcount)
   );

endmodule

/////////////////////////////////////////////////////////////////
// MODULE IDAdder_std_ic_partition_wrapper
/////////////////////////////////////////////////////////////////
module IDAdder_std_ic_partition_wrapper
(
   input logic clock,
   input logic resetn,
   output logic cra_irq_IDAdder,
   // AVS avs_IDAdder_cra
   input logic avs_IDAdder_cra_enable,
   input logic avs_IDAdder_cra_read,
   input logic avs_IDAdder_cra_write,
   input logic [4:0] avs_IDAdder_cra_address,
   input logic [63:0] avs_IDAdder_cra_writedata,
   input logic [7:0] avs_IDAdder_cra_byteenable,
   output logic [63:0] avs_IDAdder_cra_readdata,
   output logic avs_IDAdder_cra_readdatavalid
);
   logic IDAdder_start;
   logic [0:0] IDAdder_start_chain;
   logic [0:0] IDAdder_start_kernel_copy;
   logic [0:0] IDAdder_start_task_fd;
   logic [0:0] IDAdder_start_finish_element;
   logic IDAdder_finish_sig;
   logic [0:0] IDAdder_finish_kernel_copy;
   logic [0:0] IDAdder_finish_chain;
   logic [63:0] IDAdder_global_size [2:0];
   logic [31:0] IDAdder_num_groups [2:0];
   logic [31:0] IDAdder_local_size [2:0];
   logic [63:0] IDAdder_global_offset [2:0];
   logic [31:0] IDAdder_work_dim;
   logic [31:0] IDAdder_wg_size;
   logic [0:0] IDAdder_wg_disp_stall_in;
   logic [0:0] IDAdder_wg_disp_stall_in_lookahead;
   logic [0:0] IDAdder_wg_disp_valid_out;
   logic IDAdder_wg_disp_start_out;
   logic [31:0] IDAdder_wg_disp_group_id_out [2:0];
   logic [31:0] IDAdder_wg_disp_global_id_base_out [2:0];
   logic IDAdder_wg_disp_dispatched_all_groups;
   logic [63:0] IDAdder_global_id [1][2:0];
   logic [31:0] IDAdder_local_id [1][2:0];
   logic [31:0] IDAdder_group_id [1][2:0];
   logic [0:0] IDAdder_pending_write;
   logic [0:0] IDAdder_lsu_active;
   logic [0:0] IDAdder_valid_in;
   logic [0:0] IDAdder_valid_out;
   logic [0:0] IDAdder_stall_in;
   logic [0:0] IDAdder_stall_out;
   logic IDAdder_csr_pending_write;
   logic IDAdder_csr_lsu_active;
   logic IDAdder_csr_valid_in;
   logic [63:0] IDAdder_kernel_arguments;
   logic [31:0] IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_data;
   logic IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_valid;
   logic IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_almostfull;

   assign IDAdder_start_chain[0] = IDAdder_start;
   assign IDAdder_finish_chain[0] = 1'b1;
   assign IDAdder_csr_pending_write = |IDAdder_pending_write;
   assign IDAdder_csr_lsu_active = |IDAdder_lsu_active;
   assign IDAdder_csr_valid_in = |IDAdder_valid_in;
   assign IDAdder_stall_in = 0;
   // INST IDAdder_csr_agent_inst of IDAdder_function_cra_agent
   IDAdder_function_cra_agent IDAdder_csr_agent_inst
   (
      .clock(clock),
      .resetn(resetn),
      .kernel_start(IDAdder_start),
      .kernel_done(IDAdder_finish_sig),
      .has_a_lsu_active(IDAdder_csr_lsu_active),
      .has_a_write_pending(IDAdder_csr_pending_write),
      .valid_in(IDAdder_csr_valid_in),
      .kernel_arguments(IDAdder_kernel_arguments),
      .acl_c_OutputPipeID_pipe_channel_data(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_data),
      .acl_c_OutputPipeID_pipe_channel_valid(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_valid),
      .acl_c_OutputPipeID_pipe_channel_almostfull(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_almostfull),
      .cra_irq(cra_irq_IDAdder),
      // AVS avs_cra
      .avs_cra_enable(avs_IDAdder_cra_enable),
      .avs_cra_read(avs_IDAdder_cra_read),
      .avs_cra_write(avs_IDAdder_cra_write),
      .avs_cra_address(avs_IDAdder_cra_address),
      .avs_cra_writedata(avs_IDAdder_cra_writedata),
      .avs_cra_byteenable(avs_IDAdder_cra_byteenable),
      .avs_cra_readdata(avs_IDAdder_cra_readdata),
      .avs_cra_readdatavalid(avs_IDAdder_cra_readdatavalid)
   );

   // INST IDAdder_inst_0 of IDAdder_top_wrapper_0
   IDAdder_top_wrapper_0 IDAdder_inst_0
   (
      .start(IDAdder_start_kernel_copy[0]),
      .kernel_arguments(IDAdder_kernel_arguments),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_data(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_data),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_valid(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_valid),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_almostfull(IDAdder_avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_wire_acl_c_OutputPipeID_pipe_channel_almostfull),
      .kernel_valid_in(IDAdder_valid_in[0]),
      .kernel_valid_out(IDAdder_valid_out[0]),
      .has_a_write_pending(IDAdder_pending_write[0]),
      .has_a_lsu_active(IDAdder_lsu_active[0]),
      .clock(clock),
      .resetn(resetn)
   );

   // INST IDAdder_start_elem_inst_0 of acl_start_signal_chain_element
   acl_start_signal_chain_element
   #(
      .ASYNC_RESET(1),
      .SYNCHRONIZE_RESET(0)
   )
   IDAdder_start_elem_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start_in(IDAdder_start_chain[0]),
      .start_kernel(IDAdder_start_kernel_copy[0]),
      .start_finish_detector(IDAdder_start_task_fd[0]),
      .start_finish_chain_element(IDAdder_start_finish_element[0]),
      .start_chain()
   );

   // INST IDAdder_task_finish_detector_inst_0 of acl_task_copy_finish_detector
   acl_task_copy_finish_detector
   #(
      .ASYNC_RESET(1),
      .SYNCHRONIZE_RESET(0)
   )
   IDAdder_task_finish_detector_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start(IDAdder_start_task_fd[0]),
      .kernel_copy_valid_out(IDAdder_valid_out[0]),
      .kernel_copy_has_pending_write(IDAdder_pending_write[0]),
      .kernel_copy_finished(IDAdder_finish_kernel_copy[0])
   );

   // INST IDAdder_finish_elem_inst_0 of acl_finish_signal_chain_element
   acl_finish_signal_chain_element
   #(
      .ASYNC_RESET(1),
      .SYNCHRONIZE_RESET(0)
   )
   IDAdder_finish_elem_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start(IDAdder_start_finish_element[0]),
      .kernel_copy_finished(IDAdder_finish_kernel_copy[0]),
      .finish_in(IDAdder_finish_chain[0]),
      .finish_out(IDAdder_finish_sig)
   );

endmodule

/////////////////////////////////////////////////////////////////
// MODULE IDAdder_top_wrapper_0
/////////////////////////////////////////////////////////////////
module IDAdder_top_wrapper_0
(
   input logic start,
   input logic [63:0] kernel_arguments,
   output logic [31:0] avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_data,
   output logic avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_valid,
   input logic avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_almostfull,
   output logic kernel_valid_in,
   output logic kernel_valid_out,
   output logic has_a_write_pending,
   output logic has_a_lsu_active,
   input logic clock,
   input logic resetn
);
   logic lmem_invalid_single_bit;

   // INST kernel of IDAdder_function_wrapper
   IDAdder_function_wrapper kernel
   (
      .local_router_hang(lmem_invalid_single_bit),
      .start(start),
      .kernel_arguments(kernel_arguments),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_data(avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_data),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_valid(avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_valid),
      .avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_almostfull(avst_iowr_nb_acl_c_OutputPipeID_pipe_channel_almostfull),
      .kernel_valid_in(kernel_valid_in),
      .kernel_valid_out(kernel_valid_out),
      .has_a_write_pending(has_a_write_pending),
      .has_a_lsu_active(has_a_lsu_active),
      .clock(clock),
      .resetn(resetn)
   );

   assign lmem_invalid_single_bit = 'b0;
endmodule

/////////////////////////////////////////////////////////////////
// MODULE cra_ring_wrapper
/////////////////////////////////////////////////////////////////
module cra_ring_wrapper
(
   input logic clock,
   input logic resetn,
   // AVS csr_ring_root_avs
   input logic csr_ring_root_avs_enable,
   input logic csr_ring_root_avs_read,
   input logic csr_ring_root_avs_write,
   input logic [4:0] csr_ring_root_avs_address,
   input logic [63:0] csr_ring_root_avs_writedata,
   input logic [7:0] csr_ring_root_avs_byteenable,
   output logic csr_ring_root_avs_waitrequest,
   output logic [63:0] csr_ring_root_avs_readdata,
   output logic csr_ring_root_avs_readdatavalid,
   // AVM cra_ring_avm_0
   output logic cra_ring_avm_0_enable,
   output logic cra_ring_avm_0_read,
   output logic cra_ring_avm_0_write,
   output logic [4:0] cra_ring_avm_0_address,
   output logic [63:0] cra_ring_avm_0_writedata,
   output logic [7:0] cra_ring_avm_0_byteenable,
   input logic [63:0] cra_ring_avm_0_readdata,
   input logic cra_ring_avm_0_readdatavalid,
   output logic cra_ring_avm_0_burstcount
);
   logic csr_ring_root_ring_in_wire_read;
   logic csr_ring_root_ring_in_wire_write;
   logic [4:0] csr_ring_root_ring_in_wire_addr;
   logic [63:0] csr_ring_root_ring_in_wire_data;
   logic [63:0] csr_ring_root_ring_in_wire_readdata;
   logic [7:0] csr_ring_root_ring_in_wire_byteena;
   logic csr_ring_root_ring_in_wire_datavalid;
   logic csr_ring_root_ring_out_wire_read;
   logic csr_ring_root_ring_out_wire_write;
   logic [4:0] csr_ring_root_ring_out_wire_addr;
   logic [63:0] csr_ring_root_ring_out_wire_data;
   logic [63:0] csr_ring_root_ring_out_wire_readdata;
   logic [7:0] csr_ring_root_ring_out_wire_byteena;
   logic csr_ring_root_ring_out_wire_datavalid;
   logic cra_ring_node_ring_out_wire_0_read;
   logic cra_ring_node_ring_out_wire_0_write;
   logic [4:0] cra_ring_node_ring_out_wire_0_addr;
   logic [63:0] cra_ring_node_ring_out_wire_0_data;
   logic [63:0] cra_ring_node_ring_out_wire_0_readdata;
   logic [7:0] cra_ring_node_ring_out_wire_0_byteena;
   logic cra_ring_node_ring_out_wire_0_datavalid;

   // INST cra_root of cra_ring_root
   cra_ring_root
   #(
      .ADDR_W(5),
      .AGENT_PORT_WAITREQUEST_ALLOWANCE(0),
      .ALLOW_HIGH_SPEED_FIFO_USAGE(0),
      .ASYNC_RESET(1),
      .DATA_W(64),
      .ID_W(0),
      .ROM_ENABLE(0),
      .ROM_EXT_W(0),
      .SYNCHRONIZE_RESET(0),
      .ZERO_LATENCY(1)
   )
   cra_root
   (
      // AVS avs
      .avs_enable(csr_ring_root_avs_enable),
      .avs_read(csr_ring_root_avs_read),
      .avs_write(csr_ring_root_avs_write),
      .avs_addr(csr_ring_root_avs_address),
      .avs_writedata(csr_ring_root_avs_writedata),
      .avs_byteena(csr_ring_root_avs_byteenable),
      .avs_waitrequest(csr_ring_root_avs_waitrequest),
      .avs_readdata(csr_ring_root_avs_readdata),
      .avs_readdatavalid(csr_ring_root_avs_readdatavalid),
      // AVS ri
      .ri_read(cra_ring_node_ring_out_wire_0_read),
      .ri_write(cra_ring_node_ring_out_wire_0_write),
      .ri_addr(cra_ring_node_ring_out_wire_0_addr),
      .ri_data(cra_ring_node_ring_out_wire_0_data),
      .ri_readdata(cra_ring_node_ring_out_wire_0_readdata),
      .ri_byteena(cra_ring_node_ring_out_wire_0_byteena),
      .ri_datavalid(cra_ring_node_ring_out_wire_0_datavalid),
      // AVS ro
      .ro_read(csr_ring_root_ring_out_wire_read),
      .ro_write(csr_ring_root_ring_out_wire_write),
      .ro_addr(csr_ring_root_ring_out_wire_addr),
      .ro_data(csr_ring_root_ring_out_wire_data),
      .ro_readdata(csr_ring_root_ring_out_wire_readdata),
      .ro_byteena(csr_ring_root_ring_out_wire_byteena),
      .ro_datavalid(csr_ring_root_ring_out_wire_datavalid),
      .clk(clock),
      .rst_n(resetn)
   );

   // INST csr_ring_node_avm_wire_0_cra_ring_inst_0 of cra_ring_node
   cra_ring_node
   #(
      .ASYNC_RESET(1),
      .CRA_ADDR_W(5),
      .DATA_W(64),
      .ID(0),
      .ID_W(0),
      .RING_ADDR_W(5),
      .SYNCHRONIZE_RESET(0),
      .ZERO_LATENCY(1)
   )
   csr_ring_node_avm_wire_0_cra_ring_inst_0
   (
      // AVM avm
      .avm_enable(cra_ring_avm_0_enable),
      .avm_read(cra_ring_avm_0_read),
      .avm_write(cra_ring_avm_0_write),
      .avm_addr(cra_ring_avm_0_address),
      .avm_writedata(cra_ring_avm_0_writedata),
      .avm_byteena(cra_ring_avm_0_byteenable),
      .avm_readdata(cra_ring_avm_0_readdata),
      .avm_readdatavalid(cra_ring_avm_0_readdatavalid),
      .avm_burstcount(cra_ring_avm_0_burstcount),
      // AVS ri
      .ri_read(csr_ring_root_ring_out_wire_read),
      .ri_write(csr_ring_root_ring_out_wire_write),
      .ri_addr(csr_ring_root_ring_out_wire_addr),
      .ri_data(csr_ring_root_ring_out_wire_data),
      .ri_readdata(csr_ring_root_ring_out_wire_readdata),
      .ri_byteena(csr_ring_root_ring_out_wire_byteena),
      .ri_datavalid(csr_ring_root_ring_out_wire_datavalid),
      // AVS ro
      .ro_read(cra_ring_node_ring_out_wire_0_read),
      .ro_write(cra_ring_node_ring_out_wire_0_write),
      .ro_addr(cra_ring_node_ring_out_wire_0_addr),
      .ro_data(cra_ring_node_ring_out_wire_0_data),
      .ro_readdata(cra_ring_node_ring_out_wire_0_readdata),
      .ro_byteena(cra_ring_node_ring_out_wire_0_byteena),
      .ro_datavalid(cra_ring_node_ring_out_wire_0_datavalid),
      .clk(clock),
      .rst_n(resetn)
   );

endmodule

