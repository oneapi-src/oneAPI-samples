# Using the Algorithmic C Fixed Point Data-type 'ac_fixed'

This FPGA tutorial demonstrates how to use the Algorithmic C (AC) data type `ac_fixed` and some best practices.

| Optimized for                     | Description
|:---                               |:---
| OS                                | CentOS*Linux 8 <br> Red Hat* Enterprise Linux*8 <br> SUSE* Linux Enterprise Server 15 <br> Ubuntu*18.04 LTS <br> Ubuntu 20.04 <br>Windows* 10
| Hardware                          | Intel® Agilex® 7, Arria® 10, and Stratix® 10 FPGAs
| Software                          | Intel® oneAPI DPC++/C++ Compiler
| What you will learn               | How different methods of `ac_fixed` number construction affect hardware resource utilization <br>Recommended method for constructing `ac_fixed` numbers in your kernel <br>Accessing and using the `ac_fixed` math library functions <br>Trading off accuracy of results for reduced resource usage on the FPGA
| Time to complete                  | 30 minutes

> **Note**: Even though the Intel DPC++/C++ OneAPI compiler is enough to compile for emulation, generating reports and generating RTL, there are extra software requirements for the simulation flow and FPGA compiles.
>
> For using the simulator flow, Intel® Quartus® Prime Pro Edition and one of the following simulators must be installed and accessible through your PATH:
> - Questa*-Intel® FPGA Edition
> - Questa*-Intel® FPGA Starter Edition
> - ModelSim® SE
>
> When using the hardware compile flow, Intel® Quartus® Prime Pro Edition must be installed and accessible through your PATH.
>
> :warning: Make sure you add the device files associated with the FPGA that you are targeting to your Intel® Quartus® Prime installation.

## Prerequisites

This sample is part of the FPGA code samples.
It is categorized as a Tier 2 sample that demonstrates a compiler feature.

```mermaid
flowchart LR
   tier1("Tier 1: Get Started")
   tier2("Tier 2: Explore the Fundamentals")
   tier3("Tier 3: Explore the Advanced Techniques")
   tier4("Tier 4: Explore the Reference Designs")

   tier1 --> tier2 --> tier3 --> tier4

   style tier1 fill:#0071c1,stroke:#0071c1,stroke-width:1px,color:#fff
   style tier2 fill:#f96,stroke:#333,stroke-width:1px,color:#fff
   style tier3 fill:#0071c1,stroke:#0071c1,stroke-width:1px,color:#fff
   style tier4 fill:#0071c1,stroke:#0071c1,stroke-width:1px,color:#fff
```

Find more information about how to navigate this part of the code samples in the [FPGA top-level README.md](/DirectProgramming/C++SYCL_FPGA/README.md).
You can also find more information about [troubleshooting build errors](/DirectProgramming/C++SYCL_FPGA/README.md#troubleshooting), [running the sample on the Intel® DevCloud](/DirectProgramming/C++SYCL_FPGA/README.md#build-and-run-the-samples-on-intel-devcloud-optional), [using Visual Studio Code with the code samples](/DirectProgramming/C++SYCL_FPGA/README.md#use-visual-studio-code-vs-code-optional), [links to selected documentation](/DirectProgramming/C++SYCL_FPGA/README.md#documentation), etc.

## Purpose

This FPGA tutorial shows you how to use the `ac_fixed` type to perform fixed-point arithmetic and includes some simple examples.

You can use the fixed-point data type in place of native floating point types to generate area efficient and optimized designs for the FPGA. Operations which do not utilize the full dynamic range of the native types are good candidates for using `ac_fixed` types. For example: multiplying by a number in the range of `(-1.0, 1.0)`.

This tutorial shows the recommended method for constructing an `ac_fixed` number, some examples of using the fixed point math library functions, and how they can be used to reduce the area of the hardware generated by the compiler by trading off accuracy of the mathematical operations.

### Simple Code Example

An `ac_fixed` number can be defined as follows:

```cpp
ac_fixed<W, I, S> a;
```

Here `W` specifies the width in bits and `S` is a bool indicating if the number is signed. Signed numbers use the most significant bit (MSB) of the `W` bits to store the sign bit. The second parameter `I` is an integer that specifies the location of the fixed point relative to the MSB. Here are some examples of the range and quantum of `ac_fixed` numbers.

```cpp
ac_fixed<4,4,true> x; // xxxx. : range = [-8, 7], quantum = 1
ac_fixed<4,0,true> x; // .xxxx : range = [-8/16, 7/16], quantum = 1/16
ac_fixed<4,0,false> x; // .xxxx : range = [0, 15/16], quantum = 1/16
ac_fixed<4,7,false> x; // xxxx000. : range = [0, 120], quantum = 8
ac_fixed<4,-3,true> x; // (.xxxx)2^(-3) : range=[-1/16, 7/128], quantum = 1/128
```

When creating an `ac_fixed` value, the created value may be less precise than the source value or the conversion may trigger an overflow. `ac_fixed` provides enums to select quantization and overflow modes, which determine how the source value will be converted.

- The default quantization mode is `AC_TRN`, which drops bits to the right of LSB when quantization occurs.
- The default overflow mode is `AC_WRAP`, which drops bits to the left of the MSB when overflow occurs.

To select specific quantization and overflow modes, refer to section *2.1 Quantization and Overflow* in [Algorithmic C Datatypes Software Version v3.7](https://cdrdv2.intel.com/v1/dl/getContent/728986) for more details.

To use an `ac_fixed` type in your code, include the following header:

```cpp
#include <sycl/ext/intel/ac_types/ac_fixed.hpp>
```

> *IMPORTANT*: You must pass the  `-qactypes` option to the `icpx` command on Linux or the `/Qactypes` option to the `icx-cl` command on Windows when building your SYCL program in order to include `ac_types` header files on the include path and link against the AC type libraries. In this tutorial, the options are passed through the `src/CMakeLists.txt` file.

### Recommended Method for Constructing `ac_fixed` Numbers

The compiler uses significant FPGA resources to convert floating point values to `ac_fixed` values. The kernel `ConstructFromFloat` in the function `TestConstructFromFloat` constructs an `ac_fixed` object from an accessor to a native `float` type.

In contrast, the kernel `ConstructFromACFixed` in the function `TestConstructFromACFixed` constructs an `ac_fixed` object from an accessor to another `ac_fixed` object. This consumes far less area than the previous kernel. See the section on *Examining the Reports* below to understand where to look for this difference within the optimization reports.

### Using the `ac_fixed` Math Functions

To use the `ac_fixed` math functions in your code, include the following header:

```cpp
#include <sycl/ext/intel/ac_types/ac_fixed_math.hpp>
```

The functions `TestCalculateWithFloat` and `TestCalculateWithACFixed` in this tutorial design contain the kernels `CalculateWithFloat` and `CalculateWithACFixed` respectively. Both calculate the simple expression:

```cpp
  square_root ( sine(x) * sine(x) + cosine(x) * cosine(x) )
```

for some input `x`.

The kernel `CalculateWithFloat` uses floating point values and the standard math library while `CalculateWithACFixed` uses `ac_fixed` values and the `ac_fixed` math library.

In the kernel `CalculateWithACFixed`, the `sin_fixed` and `cos_fixed` functions require the integer part's bit width to be 3 and the input value range to be within [-pi, pi], while the the input width of the functions can be chosen depending on the accuracy requirement. For this tutorial, `ac_fixed` inputs are instantiated with the following parameters:

```cpp
  W = 10, I = 3, S = true
```

In this tutorial, the `ac_fixed` numbers are smaller in size than floating point numbers, which results in a reduction of the FPGA resources at the expense of accuracy. To see the trade-offs in accuracy, compare the numeric results of the operations. The area utilization differences will be discussed in the section on *Examining the Reports*.

When you use the `ac_fixed` library, keep the following points in mind:

- Input Bit Width and Input Value Range Limits

    The fixed-point math functions have bit width and input value range requirements. All bit width and input value range requirements are documented at the top of the `ac_fixed_math.hpp` file, which locates in `${ONEAPI_ROOT}/compiler/latest/linux/lib/oclfpga/include/sycl/ext/intel/ac_types` on Linux or `%ONEAPI_ROOT%\compiler\latest\windows\lib\oclfpga\include\sycl\ext\intel\ac_types` on Windows.

- Return Types

    For fixed-point functions, each function has a default return type. Assigning the result to a non-default return type triggers a type conversion and can cause an increase in logic use or a loss of accuracy in your results.  All return types are documented at the top of the `ac_fixed_math.hpp` file. For example, for `sin_fixed` and `cos_fixed`, the input type is `ac_fixed<W, 3, true>`, and the output type is `ac_fixed<W-1, 2, true>`. You can also use the `auto` type to let the compiler use the default return type.

- Accuracy
  - Floating point vs Fixed point

     The host program for this tutorial shows the accuracy differences between the result provided by floating point math library and the result provided by the `ac_fixed` math library functions, where the `float` version generates a more accurate result than the smaller-sized `ac_fixed` version.

     Note: the program is compiled with fp-model set to "precise", so the accuracy of the floating-point math functions conform to the IEEE standard.

  - Emulation vs FPGA Hardware for fixed point math operations

     Due to the differences in the internal math implementations, the results from `ac_fixed` math functions in emulation and FPGA hardware might not always be bit-accurate. This tutorial shows how to build and run the sample for emulation and FPGA hardware so you can observe the difference.

## Key Concepts

- Constructing an `ac_fixed` from a `float` or `double` value is much more area intensive than constructing one from another `ac_fixed`.
- The `ac_fixed` math library provides a set of functions for various math operations.
- The functions can be used to trade-off accuracy of results for reduced resource usage on the FPGA.
- When using these functions, be mindful of the widths of the input and return types and follow the parameterization laid out in the header file for optimal results.

## Building the `ac_fixed` Tutorial

> **Note**: When working with the command-line interface (CLI), you should configure the oneAPI toolkits using environment variables.
> Set up your CLI environment by sourcing the `setvars` script located in the root of your oneAPI installation every time you open a new terminal window.
> This practice ensures that your compiler, libraries, and tools are ready for development.
>
> Linux*:
> - For system wide installations: `. /opt/intel/oneapi/setvars.sh`
> - For private installations: ` . ~/intel/oneapi/setvars.sh`
> - For non-POSIX shells, like csh, use the following command: `bash -c 'source <install-dir>/setvars.sh ; exec csh'`
>
> Windows*:
> - `C:\Program Files(x86)\Intel\oneAPI\setvars.bat`
> - Windows PowerShell*, use the following command: `cmd.exe "/K" '"C:\Program Files (x86)\Intel\oneAPI\setvars.bat" && powershell'`
>
> For more information on configuring environment variables, see [Use the setvars Script with Linux* or macOS*](https://www.intel.com/content/www/us/en/develop/documentation/oneapi-programming-guide/top/oneapi-development-environment-setup/use-the-setvars-script-with-linux-or-macos.html) or [Use the setvars Script with Windows*](https://www.intel.com/content/www/us/en/develop/documentation/oneapi-programming-guide/top/oneapi-development-environment-setup/use-the-setvars-script-with-windows.html).

### On a Linux* System

1. Install the design in `build` directory from the design directory by running `cmake`:

  ```
  mkdir build
  cd build
  ```
  To compile for the default target (the Agilex® 7 device family), run `cmake` using the command:
  ```
  cmake ..
  ```

  > **Note**: You can change the default target by using the command:
  >  ```
  >  cmake .. -DFPGA_DEVICE=<FPGA device family or FPGA part number>
  >  ```
  >
  > Alternatively, you can target an explicit FPGA board variant and BSP by using the following command:
  >  ```
  >  cmake .. -DFPGA_DEVICE=<board-support-package>:<board-variant>
  >  ```
  >
  > You will only be able to run an executable on the FPGA if you specified a BSP.

2. Compile the design using the generated `Makefile`. The following four build targets are provided that match the recommended development flow:

   - Compile and run for emulation (fast compile time, targets emulates an FPGA device) using:

     ```bash
     make fpga_emu
     ```

   - Generate HTML optimization reports using:

     ```bash
     make report
     ```

   - Compile for simulation (fast compile time, targets simulated FPGA device)

     ```bash
     make fpga_sim
     ```

   - Compile and run on FPGA hardware (longer compile time, targets an FPGA device) using:

     ```bash
     make fpga
     ```

### On a Windows* System

1. Generate the `Makefile` by running `cmake`.

  ```
  mkdir build
  cd build
  ```
  To compile for the default target (the Agilex® 7 device family), run `cmake` using the command:
  ```
  cmake -G "NMake Makefiles" ..
  ```
  > **Note**: You can change the default target by using the command:
  >  ```
  >  cmake -G "NMake Makefiles" .. -DFPGA_DEVICE=<FPGA device family or FPGA part number>
  >  ```
  >
  > Alternatively, you can target an explicit FPGA board variant and BSP by using the following command:
  >  ```
  >  cmake -G "NMake Makefiles" .. -DFPGA_DEVICE=<board-support-package>:<board-variant>
  >  ```
  >
  > You will only be able to run an executable on the FPGA if you specified a BSP.

2. Compile the design through the generated `Makefile`. The following build targets are provided, matching the recommended development flow:

   - Compile for emulation (fast compile time, targets emulated FPGA device):

     ```
     nmake fpga_emu
     ```

   - Generate the optimization report:

     ```
     nmake report
     ```

   - Compile for simulation (fast compile time, targets simulated FPGA device, reduced problem size):

     ```
     nmake fpga_sim
     ```

   - Compile for FPGA hardware (longer compile time, targets FPGA device):

     ```
     nmake fpga
     ```

> **Note**: If you encounter any issues with long paths when compiling under Windows*, you might have to create your `build` directory in a shorter path, for example `c:\samples\build`.  You can then run `cmake` from that directory, and provide `cmake` with the full path to your sample directory.

## Examining the Reports

Locate the pair of `report.html` files in either:

- **Report-only compile**:  `ac_fixed_report.prj`
- **FPGA hardware compile**: `ac_fixed.prj`

Scroll down on the Summary page of the report and expand the section titled **Compile Estimated Kernel Resource Utilization Summary**. Observe how the kernel `ConstructFromACFixed` consumes fewer resources than the kernel named `ConstructFromFloat`. Similarly, observe how the kernel named `CalculateWithACFixed` consumes fewer FPGA resources than `CalculateWithFloat`.

## Running the Sample

1. Run the sample on the FPGA emulator (the kernel executes on the CPU):

   ```bash
   ./ac_fixed.fpga_emu    (Linux)
   ac_fixed.fpga_emu.exe  (Windows)
   ```

2. Run the sample of the FPGA simulator device (the kernel executes on the CPU):

    * On Linux
        ```bash
        CL_CONTEXT_MPSIM_DEVICE_INTELFPGA=1 ./ac_fixed.fpga_sim
        ```
    * On Windows
        ```bash
        set CL_CONTEXT_MPSIM_DEVICE_INTELFPGA=1
        ac_fixed.fpga_sim.exe
        set CL_CONTEXT_MPSIM_DEVICE_INTELFPGA=
        ```

3. Run the sample on the FPGA device (only if you ran `cmake` with `-DFPGA_DEVICE=<board-support-package>:<board-variant>`):

   ```bash
   ./ac_fixed.fpga             (Linux)
   ac_fixed.fpga.exe           (Windows)
   ```

### Example of Output on Emulator

```txt
1. Testing Constructing ac_fixed from float or ac_fixed:
Constructed from float:         3.6416015625
Constructed from ac_fixed:      3.6416015625

2. Testing calculation with float or ac_fixed math functions:
MAX DIFF (quantum) for ac_fixed<10, 3, true>:   0.0078125
MAX DIFF for float:                             9.53674e-07

Input 0:                        -0.80799192
result(fixed point):            1
difference(fixed point):        0
result(float):                  1
difference(float):              0

Input 1:                        -2.099829
result(fixed point):            0.9921875
difference(fixed point):        0.0078125
result(float):                  0.99999994
difference(float):              5.9604645e-08

Input 2:                        -0.74206626
result(fixed point):            1
difference(fixed point):        0
result(float):                  1
difference(float):              0

Input 3:                        -2.3321707
result(fixed point):            1
difference(fixed point):        0
result(float):                  1
difference(float):              0

Input 4:                        1.1432415
result(fixed point):            0.9921875
difference(fixed point):        0.0078125
result(float):                  0.99999994
difference(float):              5.9604645e-08

PASSED: all kernel results are correct.
```

### Discussion of Results

You can obtain a smaller hardware footprint for your kernel by ensuring that the `ac_fixed` numbers are constructed from `float` or `double` numbers outside the kernel. Additionally, by using the `ac_fixed` types and math library functions, you can use an even smaller fixed point format to trade-off even more accuracy for a more resource efficient design if your application requirements allow for it.

## License

Code samples are licensed under the MIT license. See [License.txt](https://github.com/oneapi-src/oneAPI-samples/blob/master/License.txt) for details.

Third-party program Licenses can be found here: [third-party-programs.txt](https://github.com/oneapi-src/oneAPI-samples/blob/master/third-party-programs.txt).
