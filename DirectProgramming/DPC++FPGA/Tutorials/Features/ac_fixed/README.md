# Using the Algorithmic C Fixed Point Data-type 'ac_fixed'

This FPGA tutorial demonstrates how to use the Algorithmic C (AC) data type `ac_fixed` and some best practices.

##### Documentation
-   The [DPC++ FPGA Code Samples Guide](https://software.intel.com/content/www/us/en/develop/articles/explore-dpcpp-through-intel-fpga-code-samples.html) helps you to navigate the samples and build your knowledge of DPC++ for FPGA.
-   The [oneAPI DPC++ FPGA Optimization Guide](https://software.intel.com/content/www/us/en/develop/documentation/oneapi-fpga-optimization-guide) is the reference manual for targeting FPGAs through DPC++.
-   The [oneAPI Programming Guide](https://software.intel.com/en-us/oneapi-programming-guide) is a general resource for target-independent DPC++ programming.

| Optimized for                     | Description
---                                 |---
| OS                                | <ul><li>CentOS* Linux 8</li><li>Red Hat* Enterprise Linux* 8</li><li>SUSE* Linux Enterprise Server 15</li><li>Ubuntu* 18.04 LTS</li><li>Ubuntu 20.04</li><li>Windows* 10</li></ul>
| Hardware                          | <ul><li>Intel® Programmable Acceleration Card (PAC) with Intel Arria® 10 GX FPGA</li><li>Intel® FPGA Programmable Acceleration Card (PAC) D5005 (with Intel Stratix® 10 SX)</li><li>Intel® FPGA 3rd party / custom platforms with oneAPI support</li></ul>*__Note__: Intel® FPGA PAC hardware is only compatible with Ubuntu 18.04*
| Software                          | <ul><li>Intel® oneAPI DPC++ Compiler</li><li>Intel® FPGA Add-On for oneAPI Base Toolkit</li></ul>
| What you will learn               | <ul><li>How different methods of `ac_fixed` number construction affect hardware resource utilization</li><li>Recommended method for constructing `ac_fixed` numbers in your kernel</li><li>Accessing and using the `ac_fixed` math library functions</li><li>Trading off accuracy of results for reduced resource usage on the FPGA</li></ul>
| Time to complete                  | 30 minutes

## Purpose

This FPGA tutorial shows you how to use the `ac_fixed` type to perform fixed-point arithmetic and includes some simple examples.

You can use the fixed-point data type in place of native floating point types to generate area efficient and optimized designs for the FPGA. Operations which do not utilize the full dynamic range of the native types are good candidates for using `ac_fixed` types. For example: multiplying by a number in the range of `(-1.0, 1.0)`.

This tutorial shows the recommended method for constructing an `ac_fixed` number, some examples of using the fixed point math library functions, and how they can be used to reduce the area of the hardware generated by the compiler by trading off accuracy of the mathematical operations.

### Simple Code Example

An `ac_fixed` number can be defined as follows:
```cpp
ac_fixed<W, I, S> a;
```
Here `W` specifies the width in bits and `S` is a bool indicating if the number is signed. Signed numbers use the most significant bit (MSB) of the `W` bits to store the sign bit. The second parameter `I` is an integer that specifies the location of the fixed point relative to the MSB. Here are some examples of the range and quantum of `ac_fixed` numbers.

```cpp
ac_fixed<4,4,true> x; // xxxx. : range = [-8, 7], quantum = 1
ac_fixed<4,0,true> x; // .xxxx : range = [-8/16, 7/16], quantum = 1/16
ac_fixed<4,0,false> x; // .xxxx : range = [0, 15/16], quantum = 1/16
ac_fixed<4,7,false> x; // xxxx000. : range = [0, 120], quantum = 8
ac_fixed<4,-3,true> x; // (.xxxx)2^(-3) : range=[-1/16, 7/128], quantum = 1/128
```

When creating an `ac_fixed` value, the created value may be less precise than the source value or the conversion may trigger an overflow. `ac_fixed` provides enums to select quantization and overflow modes, which determine how the source value will be converted.
- The default quantization mode is `AC_TRN`, which drops bits to the right of LSB when quantization occurs.
- The default overflow mode is `AC_WRAP`, which drops bits to the left of the MSB when overflow occurs.

To select specific quantization and overflow modes, refer to section *2.1 Quantization and Overflow* in [Algorithmic C Datatypes Software Version v3.7](https://cdrdv2.intel.com/v1/dl/getContent/728986) for more details.

To use an `ac_fixed` type in your code, include the following header:

```cpp
#include <sycl/ext/intel/ac_types/ac_fixed.hpp>
```
> *IMPORTANT*: You must pass the  `-qactypes` option on Linux or the `/Qactypes` option on Windows to the `dpcpp` command when compiling your SYCL program in order to ensure that the headers are correctly included. In this tutorial, the options are passed through the `src/CMakeLists.txt` file.

### Recommended Method for Constructing `ac_fixed` Numbers

The compiler uses significant FPGA resources to convert double precision (and single precision) floating-point values to `ac_fixed` values. The kernel `ConstructFromFloat` in the function `TestConstructFromFloat` constructs an `ac_fixed` object from an accessor to a native `float` type.

In contrast, the kernel `ConstructFromACFixed` in the function `TestConstructFromACFixed` constructs an `ac_fixed` object from an accessor to another `ac_fixed` object. This consumes far less area than the previous kernel. See the section on *Examining the Reports* below to understand where to look for this difference within the optimization reports.

### Using the `ac_fixed` Math Functions

To use the `ac_fixed` math functions in your code, include the following header:

```cpp
#include <sycl/ext/intel/ac_types/ac_fixed_math.hpp>
```

The functions `TestCalculateWithFloat` and `TestCalculateWithACFixed` in this tutorial design contain the kernels `CalculateWithFloat` and `CalculateWithACFixed` respectively. Both calculate the simple expression:
```cpp
  square_root ( sine(x) * sine(x) + cosine(x) * cosine(x) )
```
for some input `x`.

The kernel `CalculateWithFloat` uses floating point values and the standard math library while `CalculateWithACFixed` uses `ac_fixed` values and the `ac_fixed` math library.

In the kernel `CalculateWithACFixed`, the `sin_fixed` and `cos_fixed` functions require the integer part's bit width to be 3, and the input value range to be within [-pi, pi]. Therefore, `ac_fixed` inputs are instantiated with the following parameters:

```cpp
  W = 10, I = 3, S = true
```

In this tutorial, the `ac_fixed` numbers are smaller in size than floating point numbers, which results in a reduction of the FPGA resources at the expense of accuracy. To see the trade-offs in accuracy, compare the numeric results of the operations. The area utilization differences will be discussed in the section on *Examining the Reports*.

When you use the `ac_fixed` library, keep the following points in mind:

- Input Bit Width and Input Value Range Limits

    The fixed-point math functions have bit width and input value range requirements. All bit width and input value range requirements are documented at the top of the `ac_fixed_math.hpp` files.

- Return Types

    For fixed-point functions, each function has a default return type. Assigning the result to a non-default return type triggers a type conversion and can cause an increase in logic use or a loss of accuracy in your results.  All return types are documented at the top of the `ac_fixed_math.hpp` file. For example, for `sin_fixed` and `cos_fixed`, the input type is `ac_fixed<W, 3, true>`, and the output type is `ac_fixed<W-1, 2, true>`. You can also use the `auto` type to let the compiler use the default return type.

- Accuracy
   - Floating point vs Fixed point

     The host program for this tutorial shows the accuracy differences between the correct result and the result provided by the math library functions. The floating point version generates a more accurate result than the fixed point version.
 
   - Emulation vs FPGA Hardware for fixed point math operations

     Due to the differences in the internal math implementations, the results from `ac_fixed` math functions in emulation and FPGA hardware might not always be bit-accurate. This tutorial shows how to build and run the sample for emulation and FPGA hardware so you can observe the difference.

## Key Concepts
 * Constructing an `ac_fixed` from a `float` or `double` value is much more area intensive than constructing one from another `ac_fixed`.
 * The `ac_fixed` math library provides a set of functions for various math operations.
 * The functions can be used to trade-off accuracy of results for reduced resource usage on the FPGA.
 * When using these functions, be mindful of the widths of the input and return types and follow the parameterization laid out in the header file for optimal results.

## License

Code samples are licensed under the MIT license. See
[License.txt](https://github.com/oneapi-src/oneAPI-samples/blob/master/License.txt) for details.


## Building the `ac_fixed` Tutorial

### Include Files

The included header `dpc_common.hpp` is located at `%ONEAPI_ROOT%\dev-utilities\latest\include` on your development system.

### Running Samples in DevCloud
If you are running a sample in the Intel DevCloud, remember that you must specify the type of compute node and whether to run in batch or interactive mode:
  - Compiles to FPGA are supported only on `fpga_compile` nodes. 
  - Executing programs on FPGA hardware is supported only on `fpga_runtime` nodes of the appropriate type, such as `fpga_runtime:arria10` or `fpga_runtime:stratix10`.
 
On the login nodes, you cannot compile or execute programs on FPGA hardware. For more information, see the Intel® oneAPI Base Toolkit Get Started Guide ([https://devcloud.intel.com/oneapi/documentation/base-toolkit/](https://devcloud.intel.com/oneapi/documentation/base-toolkit/)).

When compiling for FPGA hardware, increase the job timeout to 12h.

### Using Visual Studio Code*  (Optional)

You can use Visual Studio Code (VS Code) extensions to set your environment, create launch configurations,
and browse and download samples.

The basic steps to build and run a sample using VS Code include:
 - Download a sample using the extension **Code Sample Browser for Intel oneAPI Toolkits**.
 - Configure the oneAPI environment with the extension **Environment Configurator for Intel oneAPI Toolkits**.
 - Open a Terminal in VS Code (**Terminal>New Terminal**).
 - Run the sample in the VS Code terminal using the instructions below.

To learn more about the extensions and how to configure the oneAPI environment, see
[Using Visual Studio Code with Intel® oneAPI Toolkits](https://software.intel.com/content/www/us/en/develop/documentation/using-vs-code-with-intel-oneapi/top.html).

After learning how to use the extensions for Intel oneAPI Toolkits, return to this README for instructions on how to build and run a sample.

### On a Linux* System

1. Install the design in `build` directory from the design directory by running `cmake`:

   ```bash
   mkdir build
   cd build
   ```

   If you are compiling for the Intel® PAC with Intel Arria® 10 GX FPGA, run `cmake` using the command:

   ```bash
   cmake ..
   ```

   Alternatively, to compile for the Intel® FPGA PAC D5005 (with Intel Stratix® 10 SX), run `cmake` using the command:

   ```bash
   cmake .. -DFPGA_BOARD=intel_s10sx_pac:pac_s10
   ```
   You can also compile for a custom FPGA platform. Ensure that the board support package is installed on your system. Then run `cmake` using the command:
   ```bash
   cmake .. -DFPGA_BOARD=<board-support-package>:<board-variant>
   ```

2. Compile the design using the generated `Makefile`. The following four build targets are provided that match the recommended development flow:

   * Compile and run for emulation (fast compile time, targets emulates an FPGA device) using:

     ```bash
     make fpga_emu
     ```

   * Generate HTML optimization reports using:

     ```bash
     make report
     ```

   * Compile and run on FPGA hardware (longer compile time, targets an FPGA device) using:

     ```bash
     make fpga
     ```

3. (Optional) As the earlier hardware compile can take several hours to complete, FPGA precompiled binaries (compatible with Ubuntu 18.04) can be downloaded [here](https://iotdk.intel.com/fpga-precompiled-binaries/latest/ac_fixed.fpga.tar.gz).

### On a Windows* System

1. Generate the `Makefile` by running `cmake`.
     ```
   mkdir build
   cd build
   ```
   To compile for the Intel® PAC with Intel Arria® 10 GX FPGA, run `cmake` using the command:  
    ```
    cmake -G "NMake Makefiles" ..
   ```
   Alternatively, to compile for the Intel® FPGA PAC D5005 (with Intel Stratix® 10 SX), run `cmake` using the command:

   ```
   cmake -G "NMake Makefiles" .. -DFPGA_BOARD=intel_s10sx_pac:pac_s10
   ```
   You can also compile for a custom FPGA platform. Ensure that the board support package is installed on your system. Then run `cmake` using the command:
   ```
   cmake -G "NMake Makefiles" .. -DFPGA_BOARD=<board-support-package>:<board-variant>
   ```

2. Compile the design through the generated `Makefile`. The following build targets are provided, matching the recommended development flow:

   * Compile for emulation (fast compile time, targets emulated FPGA device): 
     ```
     nmake fpga_emu
     ```
   * Generate the optimization report: 
     ```
     nmake report
     ``` 
   * Compile for FPGA hardware (longer compile time, targets FPGA device):
     ```
     nmake fpga
     ``` 

*Note:* The Intel® PAC with Intel Arria® 10 GX FPGA and Intel® FPGA PAC D5005 (with Intel Stratix® 10 SX) do not yet support Windows*. Compiling to FPGA hardware on Windows* requires a third-party or custom Board Support Package (BSP) with Windows* support.<br>
*Note:* If you encounter any issues with long paths when compiling under Windows*, you might have to create your `build` directory in a shorter path, for example `c:\samples\build`.  You can then run `cmake` from that directory, and provide `cmake` with the full path to your sample directory.
 
### In Third-Party Integrated Development Environments (IDEs)

You can compile and run this tutorial in the Eclipse* IDE (in Linux*) and the Visual Studio* IDE (in Windows*).
For instructions, refer to [*Intel® oneAPI DPC++ FPGA Workflows on Third-Party IDEs*](https://software.intel.com/en-us/articles/intel-oneapi-dpcpp-fpga-workflow-on-ide)

## Examining the Reports

Locate the pair of `report.html` files in either:

* **Report-only compile**:  `ac_fixed_report.prj`
* **FPGA hardware compile**: `ac_fixed.prj`

Scroll down on the Summary page of the report and expand the section titled **Compile Estimated Kernel Resource Utilization Summary**. Observe how the kernel `ConstructFromACFixed` consumes fewer resources than the kernel named `ConstructFromFloat`. Similarly, observe how the kernel named `CalculateWithACFixed` consumes fewer FPGA resources than `CalculateWithFloat`.

## Running the Sample

1. Run the sample on the FPGA emulator (the kernel executes on the CPU):

   ```bash
   ./ac_fixed.fpga_emu    # Linux
   ac_fixed.fpga_emu.exe  # Windows
   ```

2. Run the sample on the FPGA device

   ```bash
   ./ac_fixed.fpga             # Linux
   ```

### Example of Output

```txt
Constructed from float:         3.6416015625
Constructed from ac_fixed:      3.6416015625

MAX DIFF for ac_fixed<10, 3, true>:  0.0078125
MAX DIFF for float:                  9.53674e-07

result(fixed point): 1
result(float):       1

result(fixed point): 0.992188
result(float):       1

result(fixed point): 1
result(float):       1

result(fixed point): 1
result(float):       1

result(fixed point): 0.992188
result(float):       1

PASSED: all kernel results are correct.
```

### Discussion of Results

You can obtain a smaller hardware footprint for your kernel by ensuring that the `ac_fixed` numbers are constructed from `float` or `double` numbers outside the kernel. Additionally, you can trade-off mathematical operation accuracy for a more resource efficient design by using the `ac_fixed` math library functions.