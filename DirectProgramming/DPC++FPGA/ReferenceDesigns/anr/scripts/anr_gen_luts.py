import math
import sys
from struct import pack, unpack
import os

################################################################################
################################################################################
## You can change these parameters!
exp_filename = '../src/qfp/qfp_exp_lut.hpp'
exp_qfp_total_bits = 10
exp_qfp_exponent_bits = 6

inv_filename = '../src/qfp/qfp_pow2_lut.hpp'
inv_qfp_total_bits = 12
inv_qfp_exponent_bits = 6

inv_filename = '../src/qfp/qfp_inv_lut.hpp'
inv_qfp_total_bits = 12
inv_qfp_exponent_bits = 6
################################################################################
################################################################################


# IEEE 754 fp32 has
  #   1 sign bit
  #   8 exponent bits (biased by 127, https://en.wikipedia.org/wiki/Exponent_bias)
  #   23 mantisa bits (23 stored, 24 implicit)
  # https://en.wikipedia.org/wiki/Single-precision_floating-point_format
fp32_exponent_bits = 8
fp32_mantisa_bits = 23

#
# Prints the autogenerated message
#
def print_autogen_warning():
  print('//')
  print('// !!! AUTOGENERATED FILE; DO NOT EDIT THIS FILE !!!')
  print('// This file was automatically generated using the {} script'.format(os.path.basename(__file__)))
  print('// If you want to update this file, rerun the script:')
  print('//   python {}'.format(os.path.basename(__file__)))
  print('//')

def print_array_data(type_name, data, static_cast=False):
  print('  {} ret = {{'.format(type_name))
  for i in range(0, len(data)):
    if static_cast:
      print('    static_cast<float>({}){}'.format(data[i], (',' if i < (len(data)-1) else '')))
    else:
      print('    {}{}'.format(data[i], (',' if i < (len(data)-1) else '')))
  print('  };')

# converts a QFP to a 32-bit single precision float
def QFPtoFP32(qfp, qfp_total_bits, qfp_exponent_bits):
  qfp_mantisa_bits = qfp_total_bits - qfp_exponent_bits
  mantisa_bit_diff = fp32_mantisa_bits - qfp_mantisa_bits
  qfp_exponent_mask = (1 << qfp_exponent_bits) - 1
  qfp_mantisa_mask = (1 << qfp_mantisa_bits) - 1

  fp32_exponent_tmp = int((qfp >> qfp_mantisa_bits) & qfp_exponent_mask)
  fp32_exponent = 0 if (fp32_exponent_tmp == 0) else (fp32_exponent_tmp - 31 + 127)
  fp32_mantissa = (qfp & qfp_mantisa_mask) << mantisa_bit_diff

  fp32 = int(0)
  fp32 = (fp32_exponent << fp32_mantisa_bits) | (fp32_mantissa)

  # pack the integer into bytes
  fp32_pack = pack('i', fp32)

  # unpack the bytes into a float
  return float(unpack('f', fp32_pack)[0])

#
# Generate the exp() LUT
#
def GenerateExpLUT(filename, qfp_total_bits, qfp_exponent_bits):
  lut_depth = 2**qfp_total_bits
  
  # build the LUT
  exp_lut = [None] * lut_depth

  for i in range(0, lut_depth):
    exp_power = QFPtoFP32(i, qfp_total_bits, qfp_exponent_bits)
    try:
      exp_lut[i] = math.exp(-exp_power)
    except OverflowError:
      exp_lut[i] = float(1.0)

  # write the file
  with open(filename, 'w') as f:
    print('Writing exponential LUT to {}'.format(filename))

    # Change the standard output to the file we created.
    original_stdout = sys.stdout
    sys.stdout = f

    # write out the file
    print('#ifndef __QFP_EXP_LUT_HPP__')
    print('#define __QFP_EXP_LUT_HPP__')
    print('')
    print_autogen_warning()
    print('')
    print('#include <array>')
    print('#include "qfp.hpp"')
    print('')
    print('// the QFP format')
    print('constexpr int kExpQFPTotalBits = {};'.format(qfp_total_bits))
    print('constexpr int kExpQFPExponentBits = {};'.format(qfp_exponent_bits))
    print('')
    print('// the LUT is sized based on the number QFP bits')
    print('constexpr int kExpLUTDepth = (1 << kExpQFPTotalBits);')
    print('')
    print('// the LUT type')
    print('using ExpLUT = std::array<float, kExpLUTDepth>;')
    print('')
    print('// the QFP format')
    print('using ExpQFP = QFP<kExpQFPTotalBits, kExpQFPExponentBits, false>;')
    print('')
    print('// A constexpr function to build the exp LUT. This function computes')
    print('// exp(-x) where x is a QFP (i.e., an ac_int). You can use the')
    print('// ExpQFP::FromFP32() function to convert a 32-bit floating point')
    print('// to a QFP for indexing (see qfp.hpp).')
    print('constexpr auto BuildExpLUT() {')
    print_array_data("ExpLUT", exp_lut)
    print('')
    print('  return ret;')
    print('}')
    print('')
    print('#endif /*__QFP_EXP_LUT_HPP__*/')

    # restore stdout
    sys.stdout = original_stdout

#
# Generate the inverse (1/x) LUT
#
def GenerateInvLUT(filename, qfp_total_bits, qfp_exponent_bits):
  lut_depth = 2**qfp_total_bits

  # Build the pixel diff LUT
  inv_lut = [None] * lut_depth
  for i in range(0, lut_depth):
    i_inv = QFPtoFP32(i, qfp_total_bits, qfp_exponent_bits)
    try:
      inv_lut[i] = 1 / i_inv
    except ZeroDivisionError:
      inv_lut[i] = float(1.0)

  # write the file
  with open(filename, 'w') as f:
    print('Writing inverse LUT to {}'.format(filename))

    # Change the standard output to the file we created.
    original_stdout = sys.stdout
    sys.stdout = f

    # write out the file
    print('#ifndef __INV_LUT_HPP__')
    print('#define __INV_LUT_HPP__')
    print('')
    print_autogen_warning()
    print('')
    print('#include <array>')
    print('')
    print('// the QFP format')
    print('constexpr int kInvQFPTotalBits = {};'.format(qfp_total_bits))
    print('constexpr int kInvQFPExponentBits = {};'.format(qfp_exponent_bits))
    print('')
    print('// the LUT is sized based on the number QFP bits')
    print('constexpr int kInvLUTDepth = (1 << kInvQFPTotalBits);')
    print('')
    print('// the LUT type')
    print('using InvLUT = std::array<float, kInvLUTDepth>;')
    print('')
    print('// the QFP format')
    print('using InvQFP = QFP<kInvQFPTotalBits, kInvQFPExponentBits, false>;')
    print('')
    print('//')
    print('// A constexpr function to build the inverse LUT')
    print('//')
    print('constexpr auto BuildInvLUT() {')
    print_array_data("InvLUT", inv_lut, True)
    print('')
    print('  return ret;')
    print('}')
    print('')
    print('#endif /*__INV_LUT_HPP__*/')

    # restore stdout
    sys.stdout = original_stdout

#
# main function
#
if __name__ == "__main__":
  GenerateExpLUT(exp_filename, exp_qfp_total_bits, exp_qfp_exponent_bits)
  #GenerateInvLUT(inv_filename, inv_qfp_total_bits, inv_qfp_exponent_bits)

  print('Done')

